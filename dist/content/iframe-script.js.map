{"version":3,"file":"content/iframe-script.js","mappings":"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","sources":["webpack://chrome-extension-ai-review-replier/./src/content/iframe-script.ts"],"sourcesContent":["// AI Review Responder - Dynamic Iframe Script\n// This script runs ONLY in Google Business review iframes (automatically injected by manifest.json)\n// URL pattern: https://www.google.com/local/business/*/customers/reviews*\n\n(() => {\n  console.log('üéØ AI Review Responder iframe script loaded');\n  console.log('üìç Iframe URL:', window.location.href);\n\n  // Global state for dynamic injection system\n  let lastKnownUrl = window.location.href;\n  let mutationObserver: MutationObserver | null = null;\n  let urlCheckInterval: number | null = null;\n  let injectedButtons: Set<HTMLElement> = new Set();\n  let buttonObserver: MutationObserver | null = null; // Track button removal\n  let debounceTimer: number | null = null;\n  let lastInjectionTime = 0;\n  let isInjecting = false; // Prevent concurrent injections\n  const INJECTION_DEBOUNCE_MS = 1000; // Prevent rapid re-injection\n  const URL_CHECK_INTERVAL_MS = 500;\n\n  // Notify parent frame that iframe script is ready\n  if (window.parent && window.parent !== window) {\n    window.parent.postMessage({\n      type: 'IFRAME_READY',\n      data: {\n        url: window.location.href,\n        timestamp: new Date().toISOString()\n      }\n    }, '*');\n  }\n\n  // Listen for messages from background script (for progress updates, etc.)\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    console.log('üì® Message from background script:', message);\n\n    switch (message.type) {\n      case 'AI_RESPONSE_RESULT':\n        handleAIResponseResult(message.data);\n        break;\n\n      case 'PROGRESS_UPDATE':\n        handleProgressUpdate(message.data);\n        break;\n\n      default:\n        console.log('Unknown message type from background:', message.type);\n    }\n\n    sendResponse({ success: true });\n  });\n\n  // Determine if this is a single review reply iframe or multi-review iframe\n  const currentUrl = window.location.href;\n  const hasCustomersReviews = currentUrl.includes('/customers/reviews');\n  const isSingleReviewReply = currentUrl.includes('/customers/reviews/reply');\n\n  console.log('üîç URL Analysis:', {\n    fullUrl: currentUrl,\n    hasCustomersReviews: hasCustomersReviews,\n    isSingleReviewReply: isSingleReviewReply,\n    pattern: hasCustomersReviews ? (isSingleReviewReply ? 'SINGLE_REVIEW_REPLY' : 'MULTI_REVIEW_VIEW') : 'UNKNOWN'\n  });\n\n  if (hasCustomersReviews) {\n    console.log('üöÄ Initializing Dynamic AI Button Injection System');\n    initializeDynamicInjectionSystem();\n  } else {\n    console.log('üö´ This iframe does not match Google Business review patterns');\n    console.log('üîç Iframe URL:', currentUrl);\n  }\n\n  // ==================== DYNAMIC INJECTION SYSTEM ====================\n\n  function initializeDynamicInjectionSystem() {\n    console.log('üöÄ Initializing Dynamic AI Button Injection System');\n\n    // Set up content change detection\n    setupContentChangeDetection();\n\n    // Set up DOM mutation monitoring\n    setupMutationObserver();\n\n    // Initial scan for existing textareas\n    console.log('üîç Performing initial textarea scan');\n    debouncedInjectAIButtons();\n\n    // Set up button removal observer\n    setupButtonObserver();\n\n    console.log('‚úÖ Dynamic injection system initialized');\n    console.log('üìä System Status:', {\n      urlMonitoring: 'ACTIVE',\n      mutationObserver: 'ACTIVE',\n      buttonObserver: 'ACTIVE',\n      injectedButtons: injectedButtons.size,\n      lastInjectionTime: new Date(lastInjectionTime).toISOString()\n    });\n  }\n\n  function setupContentChangeDetection() {\n    console.log('üîÑ Setting up iframe content change detection');\n\n    urlCheckInterval = window.setInterval(() => {\n      const currentUrl = window.location.href;\n\n      if (currentUrl !== lastKnownUrl) {\n        console.log('üîÑ Iframe URL changed:', {\n          from: lastKnownUrl,\n          to: currentUrl,\n          timestamp: new Date().toISOString()\n        });\n\n        lastKnownUrl = currentUrl;\n        handleContentChange();\n      }\n    }, URL_CHECK_INTERVAL_MS);\n\n    console.log('‚úÖ URL change detection active');\n  }\n\n  function setupMutationObserver() {\n    console.log('üëÅÔ∏è Setting up MutationObserver for DOM changes');\n\n    mutationObserver = new MutationObserver((mutations) => {\n      let shouldTriggerScan = false;\n      let relevantChanges: string[] = [];\n\n      mutations.forEach(mutation => {\n        if (mutation.type === 'childList') {\n          // Check for our specific textarea (jsname=\"YPqjbf\") being added or removed\n          mutation.addedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              const element = node as Element;\n              if (element.matches('[jsname=\"YPqjbf\"]') ||\n                  element.querySelector('[jsname=\"YPqjbf\"]')) {\n                shouldTriggerScan = true;\n                relevantChanges.push('textarea_added');\n                console.log('üìù Specific textarea (YPqjbf) added to DOM');\n              }\n            }\n          });\n\n          mutation.removedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              const element = node as Element;\n              if (element.matches('[jsname=\"YPqjbf\"]') ||\n                  element.querySelector('[jsname=\"YPqjbf\"]')) {\n                shouldTriggerScan = true;\n                relevantChanges.push('textarea_removed');\n                console.log('üóëÔ∏è Specific textarea (YPqjbf) removed from DOM');\n              }\n            }\n          });\n\n          // Also check for significant structural changes that might affect our textarea\n          if (!shouldTriggerScan && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {\n            // Look for changes in form containers or review-related elements\n            const hasStructuralChanges = Array.from(mutation.addedNodes).some(node => {\n              if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node as Element;\n                return element.matches('form, .modal, .dialog, .review-reply-container, .reply-form') ||\n                       element.querySelector('form, .modal, .dialog, .review-reply-container, .reply-form');\n              }\n              return false;\n            });\n\n            if (hasStructuralChanges) {\n              shouldTriggerScan = true;\n              relevantChanges.push('structural_change');\n              console.log('üèóÔ∏è Structural changes detected that may affect textarea');\n            }\n          }\n        } else if (mutation.type === 'attributes') {\n          // Check if our specific textarea's attributes changed\n          if (mutation.target.nodeType === Node.ELEMENT_NODE) {\n            const element = mutation.target as Element;\n            if (element.matches('[jsname=\"YPqjbf\"]') &&\n                ['id', 'class', 'placeholder', 'jsname'].includes(mutation.attributeName || '')) {\n              shouldTriggerScan = true;\n              relevantChanges.push('textarea_attribute_changed');\n              console.log('üîÑ Specific textarea attributes changed');\n            }\n          }\n        }\n      });\n\n      if (shouldTriggerScan) {\n        console.log('üîÑ Relevant DOM changes detected:', {\n          changes: relevantChanges,\n          timestamp: new Date().toISOString()\n        });\n        handleTextareaChanges();\n      }\n    });\n\n    // Start observing with more targeted configuration\n    mutationObserver.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['id', 'class', 'placeholder', 'jsname']\n    });\n\n    console.log('‚úÖ MutationObserver active - monitoring for specific textarea changes');\n  }\n\n  function setupButtonObserver() {\n    console.log('üëÅÔ∏è Setting up Button Observer for removal tracking');\n\n    buttonObserver = new MutationObserver((mutations) => {\n      mutations.forEach(mutation => {\n        if (mutation.type === 'childList') {\n          mutation.removedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              const element = node as Element;\n              if (element.classList.contains('ai-review-button')) {\n                console.log('üóëÔ∏è Button removed from DOM, updating tracking');\n                injectedButtons.delete(element as HTMLElement);\n              }\n              // Also check for buttons inside removed containers\n              const removedButtons = element.querySelectorAll('.ai-review-button');\n              removedButtons.forEach(button => {\n                console.log('üóëÔ∏è Button in removed container, updating tracking');\n                injectedButtons.delete(button as HTMLElement);\n              });\n            }\n          });\n        }\n      });\n    });\n\n    // Observe the entire document for button removal\n    buttonObserver.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n\n    console.log('‚úÖ Button Observer active - tracking button removal');\n  }\n\n  function handleContentChange() {\n    console.log('üîÑ Handling iframe content change');\n    console.log('üßπ Cleaning up existing buttons due to content change');\n\n    cleanupOrphanedButtons();\n\n    // Don't trigger injection immediately - let the MutationObserver handle it\n    // when the new textarea appears in the DOM\n    console.log('üëÅÔ∏è Waiting for MutationObserver to detect new textarea...');\n  }\n\n  function handleTextareaChanges() {\n    console.log('üîÑ Handling textarea DOM changes');\n    debouncedInjectAIButtons();\n  }\n\n  function debouncedInjectAIButtons() {\n    const now = Date.now();\n    const timeSinceLastInjection = now - lastInjectionTime;\n\n    // Clear any existing timer first\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n      debounceTimer = null;\n      console.log('üîÑ Cleared existing debounce timer');\n    }\n\n    if (timeSinceLastInjection < INJECTION_DEBOUNCE_MS) {\n      const remainingTime = INJECTION_DEBOUNCE_MS - timeSinceLastInjection;\n\n      debounceTimer = window.setTimeout(() => {\n        console.log('‚è≥ Debounce timer expired, performing injection');\n        performInjection();\n        debounceTimer = null;\n      }, remainingTime);\n\n      console.log(`‚è≥ Debouncing injection (will execute in ${remainingTime}ms)`);\n    } else {\n      console.log('‚ö° Performing immediate injection (debounce period passed)');\n      performInjection();\n    }\n  }\n\n  function performInjection() {\n    // Prevent concurrent injections\n    if (isInjecting) {\n      console.log('‚è≥ Injection already in progress, skipping duplicate attempt');\n      return;\n    }\n\n    isInjecting = true;\n    console.log('üéØ Performing AI button injection');\n    lastInjectionTime = Date.now();\n\n    try {\n      // Clean up orphaned buttons first\n      cleanupOrphanedButtons();\n\n      // Find all textareas that need enhancement\n      const textareas = findAllReplyTextareas();\n\n      if (textareas.length > 0) {\n        console.log(`‚úÖ Found ${textareas.length} textarea(s) for enhancement`);\n\n        let successfulInjections = 0;\n        let skippedInjections = 0;\n\n        textareas.forEach((textarea, index) => {\n          const existingButton = findExistingButtonForTextarea(textarea);\n          if (existingButton) {\n            console.log(`‚è≠Ô∏è Skipping injection for textarea ${index + 1} - button already exists`);\n            skippedInjections++;\n          } else {\n            const success = injectAIButtonForTextarea(textarea, index);\n            if (success) {\n              successfulInjections++;\n            }\n          }\n        });\n\n        console.log('üìä Injection summary:', {\n          found: textareas.length,\n          successful: successfulInjections,\n          skipped: skippedInjections,\n          totalButtons: injectedButtons.size\n        });\n      } else {\n        console.log('‚ö†Ô∏è No eligible textareas found for enhancement');\n      }\n\n      console.log('üìä Injection complete - Current status:', {\n        injectedButtons: injectedButtons.size,\n        timestamp: new Date().toISOString()\n      });\n    } finally {\n      // Always reset the flag\n      isInjecting = false;\n    }\n  }\n\n  function findAllReplyTextareas(): HTMLTextAreaElement[] {\n    console.log('üîç Scanning for reply textareas using specific selector');\n\n    // Use only the specific Google selector provided by the user\n    const specificSelector = '[jsname=\"YPqjbf\"]';\n    const foundTextareas: HTMLTextAreaElement[] = [];\n\n    try {\n      const element = document.querySelector(specificSelector) as HTMLTextAreaElement;\n\n      if (element && (element.tagName === 'TEXTAREA' || element.hasAttribute('contenteditable'))) {\n        // Verify this is actually a reply textarea and not already processed\n        if (isLikelyReplyTextarea(element) && !hasAssociatedButton(element)) {\n          foundTextareas.push(element);\n          console.log(`‚úÖ Found reply textarea: ${specificSelector}`, {\n            id: element.id,\n            className: element.className,\n            jsname: element.getAttribute('jsname'),\n            placeholder: (element as HTMLTextAreaElement | HTMLInputElement).placeholder || element.getAttribute('data-placeholder'),\n            isContentEditable: element.hasAttribute('contenteditable')\n          });\n        } else if (hasAssociatedButton(element)) {\n          console.log(`‚è≠Ô∏è Textarea already has associated button, skipping:`, {\n            id: element.id,\n            jsname: element.getAttribute('jsname')\n          });\n        }\n      } else {\n        console.log('‚ö†Ô∏è No textarea found with jsname=\"YPqjbf\"');\n      }\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Error with selector ${specificSelector}:`, error);\n    }\n\n    console.log(`üìä Found ${foundTextareas.length} eligible textarea(s) for enhancement`);\n    return foundTextareas;\n  }\n\n  function isLikelyReplyTextarea(element: HTMLElement): boolean {\n    // Since we're using the specific jsname=\"YPqjbf\" selector, we can be more lenient\n    // but still verify it's actually a reply-related textarea\n\n    // Check if it's a textarea or contenteditable\n    if (element.tagName !== 'TEXTAREA' && !element.hasAttribute('contenteditable')) {\n      return false;\n    }\n\n    // Check if it has the specific jsname attribute we expect\n    if (element.getAttribute('jsname') !== 'YPqjbf') {\n      return false;\n    }\n\n    // Additional validation for reply-related context\n    const placeholder = (element as HTMLTextAreaElement | HTMLInputElement).placeholder || element.getAttribute('data-placeholder') || '';\n    const keywords = ['reply', 'respond', 'comment', 'response'];\n\n    const hasReplyKeyword = keywords.some(keyword =>\n      placeholder.toLowerCase().includes(keyword)\n    );\n\n    // Check if element is in a form context (Google Business reviews are typically in forms)\n    const isInForm = element.closest('form') !== null;\n\n    // Since we found it with the specific selector, it's likely valid, but let's be thorough\n    return hasReplyKeyword || isInForm || element.getAttribute('jsname') === 'YPqjbf';\n  }\n\n  function hasAssociatedButton(textarea: HTMLElement): boolean {\n    // Check if there's already a button for this specific textarea (by jsname)\n    const jsname = textarea.getAttribute('jsname');\n    const textareaId = textarea.id;\n\n    if (jsname) {\n      // Check all buttons associated with this jsname\n      const allButtons = document.querySelectorAll('.ai-review-button');\n      for (const button of allButtons) {\n        const buttonJsname = button.getAttribute('data-associated-jsname');\n        if (buttonJsname === jsname) {\n          console.log(`üîó Found existing button for jsname:`, jsname);\n          return true;\n        }\n      }\n    }\n\n    // Also check if there's a button in the same container\n    const container = textarea.closest('form, .modal, .dialog, .review-reply-container') || textarea.parentElement;\n    if (container) {\n      const nearbyButton = container.querySelector('.ai-review-button');\n      if (nearbyButton) {\n        console.log(`üîó Found nearby button in container for textarea:`, textareaId || jsname);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function cleanupOrphanedButtons() {\n    console.log('üßπ Cleaning up orphaned AI buttons');\n\n    const existingButtons = document.querySelectorAll('.ai-review-button');\n    let cleanedCount = 0;\n\n    existingButtons.forEach(button => {\n      const associatedJsname = button.getAttribute('data-associated-jsname');\n      const injectionTimestamp = button.getAttribute('data-injection-timestamp');\n\n      // Check if the associated textarea still exists\n      let textareaExists = false;\n      if (associatedJsname) {\n        const textarea = document.querySelector(`[jsname=\"${associatedJsname}\"]`);\n        textareaExists = textarea !== null && document.contains(textarea);\n      }\n\n      // If textarea doesn't exist, always remove the button\n      if (!textareaExists) {\n        console.log(`üóëÔ∏è Removing orphaned button for jsname:`, associatedJsname);\n        if (button.parentNode) {\n          button.remove();\n        }\n        injectedButtons.delete(button as HTMLElement);\n        cleanedCount++;\n      }\n      // Only remove old buttons if they're really old (>10 minutes) to avoid removing active buttons\n      else if (injectionTimestamp) {\n        const buttonAge = Date.now() - parseInt(injectionTimestamp);\n        const isVeryOldButton = buttonAge > 10 * 60 * 1000; // 10 minutes\n\n        if (isVeryOldButton) {\n          console.log(`üóëÔ∏è Removing very old button (${Math.round(buttonAge / 1000 / 60)}min old) for jsname:`, associatedJsname);\n          button.remove();\n          injectedButtons.delete(button as HTMLElement);\n          cleanedCount++;\n        }\n      }\n    });\n\n    if (cleanedCount > 0) {\n      console.log(`üßπ Cleaned up ${cleanedCount} orphaned/old button(s)`);\n    } else {\n      console.log('‚úÖ No orphaned buttons found');\n    }\n  }\n\n  function findAssociatedTextarea(button: Element): HTMLElement | null {\n    console.log('üîç Looking for associated textarea...');\n\n    // First, try to find the specific textarea with jsname=\"YPqjbf\" (Google's reply textarea)\n    const googleReplyTextarea = document.querySelector('textarea[jsname=\"YPqjbf\"]') ||\n                               document.querySelector('[jsname=\"YPqjbf\"]');\n    if (googleReplyTextarea) {\n      console.log('‚úÖ Found Google reply textarea with jsname=\"YPqjbf\":', googleReplyTextarea);\n      return googleReplyTextarea as HTMLElement;\n    }\n\n    // Fallback: Try to find textarea in the same container or nearby\n    const container = button.parentElement;\n    if (container) {\n      const textarea = container.querySelector('textarea') ||\n                      container.querySelector('[contenteditable=\"true\"]');\n      if (textarea) {\n        console.log('‚úÖ Found textarea in same container:', textarea);\n        return textarea as HTMLElement;\n      }\n    }\n\n    // Look for textarea before the button's container\n    const previousTextarea = button.parentElement?.previousElementSibling?.querySelector('textarea') ||\n                           button.parentElement?.previousElementSibling?.querySelector('[contenteditable=\"true\"]');\n    if (previousTextarea) {\n      console.log('‚úÖ Found textarea in previous sibling:', previousTextarea);\n      return previousTextarea as HTMLElement;\n    }\n\n    // Last resort: look for any textarea on the page\n    const anyTextarea = document.querySelector('textarea');\n    if (anyTextarea) {\n      console.log('‚ö†Ô∏è Found any textarea as fallback:', anyTextarea);\n      return anyTextarea as HTMLElement;\n    }\n\n    console.log('‚ùå No textarea found');\n    return null;\n  }\n\n  function injectAIButtonForTextarea(textarea: HTMLElement, index: number): boolean {\n    // Check if we already have a button for this textarea\n    const existingButton = findExistingButtonForTextarea(textarea);\n\n    if (existingButton) {\n      console.log(`‚è≠Ô∏è Button already exists for textarea ${index + 1}, skipping injection`);\n      return false;\n    }\n\n    console.log(`üéØ Injecting AI button for textarea ${index + 1}:`, {\n      jsname: textarea.getAttribute('jsname'),\n      id: textarea.id,\n      className: textarea.className\n    });\n\n    try {\n      const button = createAIButton(textarea);\n      const injectionPoint = findBestInjectionPoint(textarea);\n\n      if (injectionPoint) {\n        injectButtonAtPoint(button, injectionPoint, textarea);\n        injectedButtons.add(button);\n        console.log(`‚úÖ AI button successfully injected for textarea ${index + 1}`);\n        return true;\n      } else {\n        console.warn(`‚ö†Ô∏è No suitable injection point found for textarea ${index + 1}`);\n        return false;\n      }\n    } catch (error) {\n      console.error(`‚ùå Failed to inject button for textarea ${index + 1}:`, error);\n      return false;\n    }\n  }\n\n  function findExistingButtonForTextarea(textarea: HTMLElement): HTMLElement | null {\n    // Comprehensive search for existing buttons associated with this textarea\n\n    // Method 1: Check by associated textarea ID in button attributes\n    const textareaId = textarea.id || textarea.getAttribute('jsname') || 'anonymous-textarea';\n    const allButtons = document.querySelectorAll('.ai-review-button');\n\n    for (const button of allButtons) {\n      const buttonTextareaId = button.getAttribute('data-associated-textarea');\n      if (buttonTextareaId === textareaId && injectedButtons.has(button as HTMLElement)) {\n        console.log(`üîç Found existing button by ID association:`, textareaId);\n        return button as HTMLElement;\n      }\n    }\n\n    // Method 2: Check in the same container hierarchy\n    const containerSelectors = [\n      '.review-reply-container',\n      '.reply-form',\n      'form',\n      '.modal',\n      '.dialog',\n      '.review-item',\n      '.comment-form'\n    ];\n\n    for (const selector of containerSelectors) {\n      const container = textarea.closest(selector);\n      if (container) {\n        const button = container.querySelector('.ai-review-button') as HTMLElement;\n        if (button && injectedButtons.has(button)) {\n          console.log(`üîç Found existing button in container:`, selector);\n          return button;\n        }\n      }\n    }\n\n    // Method 3: Check parent elements (up to 3 levels)\n    let currentElement: HTMLElement | null = textarea;\n    for (let i = 0; i < 3 && currentElement; i++) {\n      const button = currentElement.querySelector('.ai-review-button') as HTMLElement;\n      if (button && injectedButtons.has(button)) {\n        console.log(`üîç Found existing button in parent element (level ${i + 1})`);\n        return button;\n      }\n      currentElement = currentElement.parentElement;\n    }\n\n    console.log(`üîç No existing button found for textarea:`, textareaId);\n    return null;\n  }\n\n  function createAIButton(textarea: HTMLElement): HTMLElement {\n    const button = document.createElement('button');\n    button.textContent = 'ü§ñ Generate AI Reply';\n    button.className = 'ai-review-button VfPpkd-LgbsSe VfPpkd-LgbsSe-OWXEXe-k8QpJ VfPpkd-LgbsSe-OWXEXe-dgl2Hf nCP5yc AjY5Oe DuMIQc LQeN7 FwaX8';\n    button.setAttribute('data-textarea-id', textarea.id || 'textarea-' + Date.now());\n\n    button.style.cssText = `\n      margin: 0 8px 0 0;\n      padding: 8px 16px;\n      background: #1a73e8;\n      color: white;\n      border: none;\n      border-radius: 4px;\n      cursor: pointer;\n      font-size: 14px;\n      font-family: 'Google Sans', Roboto, Arial, sans-serif;\n      font-weight: 500;\n      transition: background-color 0.2s;\n      box-shadow: 0 1px 3px rgba(0,0,0,0.3);\n    `;\n\n    // Add hover effects\n    button.onmouseover = () => button.style.backgroundColor = '#1557b0';\n    button.onmouseout = () => button.style.backgroundColor = '#1a73e8';\n\n    // Add click handler\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      generateAIReply(textarea);\n    });\n\n    // Add Google-like inner structure\n    button.innerHTML = `\n      <div class=\"VfPpkd-Jh9lGc\"></div>\n      <div class=\"VfPpkd-J1Ukfc-LhBDec\"></div>\n      <div class=\"VfPpkd-RLmnJb\"></div>\n      <span jsname=\"V67aGc\" class=\"VfPpkd-vQzf8d\">ü§ñ Generate AI Reply</span>\n    `;\n\n    return button;\n  }\n\n  function findBestInjectionPoint(textarea: HTMLElement): { container: HTMLElement; reference: HTMLElement | null } | null {\n    // Strategy 1: Look for Google-specific button container\n    const googleContainer = document.querySelector('div.FkJOzc.lgfhc.LW6Hp') as HTMLElement;\n    if (googleContainer) {\n      const skipButton = googleContainer.querySelector('button[jsname=\"dmDvRc\"]') as HTMLElement;\n      if (skipButton) {\n        console.log('üéØ Found Google button container with Skip button');\n        return { container: googleContainer, reference: skipButton };\n      }\n      // Use any button in the container\n      const anyButton = googleContainer.querySelector('button') as HTMLElement;\n      if (anyButton) {\n        console.log('üéØ Found Google button container with alternative button');\n        return { container: googleContainer, reference: anyButton };\n      }\n    }\n\n    // Strategy 2: Find form buttons container\n    const form = textarea.closest('form');\n    if (form) {\n      const buttonContainer = form.querySelector('.button-container, .form-actions, .actions') as HTMLElement;\n      if (buttonContainer) {\n        console.log('üéØ Found form button container');\n        return { container: buttonContainer, reference: buttonContainer.firstElementChild as HTMLElement };\n      }\n    }\n\n    // Strategy 3: Insert next to textarea\n    if (textarea.parentElement) {\n      console.log('üéØ Using textarea parent as injection point');\n      return { container: textarea.parentElement, reference: textarea.nextElementSibling as HTMLElement };\n    }\n\n    console.warn('‚ö†Ô∏è No suitable injection point found');\n    return null;\n  }\n\n  function injectButtonAtPoint(button: HTMLElement, injectionPoint: { container: HTMLElement; reference: HTMLElement | null }, textarea: HTMLElement) {\n    if (injectionPoint.reference) {\n      // Insert before reference element\n      injectionPoint.container.insertBefore(button, injectionPoint.reference);\n      console.log('üöÄ Button injected before reference element');\n    } else {\n      // Append to container\n      injectionPoint.container.appendChild(button);\n      console.log('üöÄ Button appended to container');\n    }\n\n    // Mark button as injected for this textarea using jsname for better identification\n    const textareaIdentifier = textarea.getAttribute('jsname') || textarea.id || 'anonymous-textarea';\n    button.setAttribute('data-associated-textarea', textareaIdentifier);\n    button.setAttribute('data-associated-jsname', textarea.getAttribute('jsname') || '');\n    button.setAttribute('data-injection-timestamp', Date.now().toString());\n\n    console.log(`üè∑Ô∏è Button associated with textarea:`, textareaIdentifier);\n  }\n\n  // ==================== LEGACY FUNCTIONS (KEPT FOR COMPATIBILITY) ====================\n\n  function initializeReplyFormEnhancement() {\n    console.log('üé® Legacy reply form enhancement (redirecting to dynamic system)');\n    initializeDynamicInjectionSystem();\n  }\n\n  function enhanceReplyForm(replyTextarea: HTMLElement) {\n    console.log('üé® Legacy form enhancement called - using dynamic system');\n    // This function is now handled by the dynamic injection system\n    // Just trigger a scan for this specific textarea\n    debouncedInjectAIButtons();\n  }\n\n  function insertAIButton(container: HTMLElement, referenceButton: HTMLElement, replyTextarea: HTMLElement) {\n    console.log('üîÑ Legacy button insertion called - using dynamic system');\n    // This is now handled by injectButtonAtPoint\n    const injectionPoint = { container, reference: referenceButton };\n    const button = createAIButton(replyTextarea);\n    injectButtonAtPoint(button, injectionPoint, replyTextarea);\n    injectedButtons.add(button);\n  }\n\n  function fallbackButtonInjection(replyTextarea: HTMLElement) {\n    console.log('üîÑ Legacy fallback injection called - using dynamic system');\n    // This is now handled by findBestInjectionPoint strategy 3\n    debouncedInjectAIButtons();\n  }\n\n  function generateAIReply(replyElement: HTMLElement) {\n    console.log('ü§ñ Generating AI reply for element:', {\n      tagName: replyElement.tagName,\n      id: replyElement.id,\n      className: replyElement.className,\n      hasContentEditable: replyElement.hasAttribute('contenteditable')\n    });\n\n    try {\n      // Extract review data using the provided selectors\n      const reviewData = extractReviewData();\n      if (!reviewData) {\n        console.error('‚ùå Could not extract review data');\n        showErrorMessage('Could not extract review data. Please try again.');\n        return;\n      }\n\n      console.log('üìù Extracted review data:', {\n        reviewer: reviewData.reviewer_name,\n        rating: reviewData.review_rating,\n        textLength: reviewData.review_text ? reviewData.review_text.length : 0,\n        isEmptyReview: reviewData.review_text === \"[Review with no text content]\"\n      });\n\n      // Show loading state\n      showLoadingState(replyElement);\n\n      // Send message to background script to generate AI response\n      chrome.runtime.sendMessage({\n        type: 'GENERATE_AI_RESPONSE',\n        data: {\n          reviewData: reviewData,\n          mode: getSelectedMode() // We'll implement this to get mode from popup or default\n        }\n      }, (response) => {\n        console.log('üì® Received response from background:', response);\n\n        if (response && response.success) {\n          // Success - insert the generated response\n          const aiResponse = response.aiResponse || '';\n\n          // Only insert if we have a valid response or if textarea is empty\n          // This prevents overwriting a valid response with an empty one\n          const currentValue = replyElement.tagName === 'TEXTAREA' || replyElement.tagName === 'INPUT'\n            ? (replyElement as HTMLInputElement | HTMLTextAreaElement).value\n            : replyElement.textContent || '';\n\n          if (aiResponse.length > 0 || currentValue.length === 0) {\n            console.log('üìù Inserting response via callback:', {\n              responseLength: aiResponse.length,\n              currentTextareaLength: currentValue.length\n            });\n            insertGeneratedResponse(replyElement, aiResponse);\n            console.log('‚úÖ AI reply generated and inserted successfully');\n          } else {\n            console.log('‚è≠Ô∏è Skipping callback insertion - textarea already has content and response is empty');\n          }\n\n          // Notify parent frame\n          if (window.parent && window.parent !== window) {\n            window.parent.postMessage({\n              type: 'REPLY_GENERATED',\n              data: {\n                replyLength: aiResponse.length,\n                reviewTextLength: reviewData.review_text ? reviewData.review_text.length : 0,\n                confidence: response.confidence,\n                processingTime: response.processingTime,\n                tokensUsed: response.tokensUsed,\n                timestamp: new Date().toISOString()\n              }\n            }, '*');\n          }\n        } else {\n          // Error handling\n          console.error('‚ùå Error generating AI response:', response?.error);\n          showErrorMessage(response?.error || 'Failed to generate AI response');\n          hideLoadingState(replyElement);\n        }\n      });\n\n    } catch (error) {\n      console.error('‚ùå Error in generateAIReply:', error);\n      showErrorMessage('An unexpected error occurred. Please try again.');\n      hideLoadingState(replyElement);\n    }\n  }\n\n  function getSelectedMode(): 'simple' | 'pro' {\n    // For now, default to simple mode\n    // TODO: Get this from popup settings or user preference\n    return 'simple';\n  }\n\n  function showLoadingState(replyElement: HTMLElement) {\n    // Disable the button and show loading state\n    const button = document.querySelector('.ai-review-button') as HTMLElement;\n    if (button) {\n      button.textContent = 'ü§ñ Generating...';\n      button.style.opacity = '0.6';\n      button.style.pointerEvents = 'none';\n    }\n\n    // Optionally show a loading indicator in the textarea\n    if (replyElement.hasAttribute('placeholder')) {\n      const originalPlaceholder = replyElement.getAttribute('placeholder') || '';\n      replyElement.setAttribute('data-original-placeholder', originalPlaceholder);\n      replyElement.setAttribute('placeholder', 'Generating AI response...');\n    }\n  }\n\n  function hideLoadingState(replyElement: HTMLElement) {\n    // Re-enable the button\n    const button = document.querySelector('.ai-review-button') as HTMLElement;\n    if (button) {\n      button.textContent = 'ü§ñ Generate AI Reply';\n      button.style.opacity = '1';\n      button.style.pointerEvents = 'auto';\n    }\n\n    // Restore original placeholder\n    if (replyElement.hasAttribute('data-original-placeholder')) {\n      const originalPlaceholder = replyElement.getAttribute('data-original-placeholder') || '';\n      replyElement.setAttribute('placeholder', originalPlaceholder);\n      replyElement.removeAttribute('data-original-placeholder');\n    }\n  }\n\n  function insertGeneratedResponse(replyElement: HTMLElement, response: string) {\n    console.log('üìù Attempting to insert response into element:', {\n      tagName: replyElement.tagName,\n      id: replyElement.id,\n      jsname: replyElement.getAttribute('jsname'),\n      className: replyElement.className,\n      responseLength: response.length,\n      responsePreview: response.substring(0, 100) + (response.length > 100 ? '...' : '')\n    });\n\n    hideLoadingState(replyElement);\n\n    // Fill the reply form\n    if (replyElement.tagName === 'TEXTAREA' || replyElement.tagName === 'INPUT') {\n      (replyElement as HTMLInputElement | HTMLTextAreaElement).value = response;\n      console.log('‚úÖ Set textarea/input value, current value length:', (replyElement as HTMLInputElement | HTMLTextAreaElement).value.length);\n      // Trigger input event to notify any listeners\n      replyElement.dispatchEvent(new Event('input', { bubbles: true }));\n    } else if (replyElement.hasAttribute('contenteditable')) {\n      replyElement.textContent = response;\n      console.log('‚úÖ Set contenteditable textContent, current text length:', replyElement.textContent?.length);\n      // Trigger input event for contenteditable\n      replyElement.dispatchEvent(new Event('input', { bubbles: true }));\n    } else {\n      console.log('‚ö†Ô∏è Element is neither textarea/input nor contenteditable');\n    }\n\n    // Optionally, focus the element to show the response\n    replyElement.focus();\n    console.log('‚úÖ Focused the element');\n  }\n\n  function showErrorMessage(message: string) {\n    // Create a temporary error message\n    const errorDiv = document.createElement('div');\n    errorDiv.textContent = `‚ùå ${message}`;\n    errorDiv.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: #f44336;\n      color: white;\n      padding: 12px 16px;\n      border-radius: 4px;\n      font-size: 14px;\n      z-index: 10000;\n      box-shadow: 0 2px 8px rgba(0,0,0,0.3);\n      max-width: 300px;\n    `;\n\n    document.body.appendChild(errorDiv);\n\n    // Remove after 5 seconds\n    setTimeout(() => {\n      if (errorDiv.parentNode) {\n        errorDiv.remove();\n      }\n    }, 5000);\n  }\n\n  function handleAIResponseResult(data: any) {\n    console.log('ü§ñ Handling AI response result:', data);\n\n    try {\n      // Find the associated textarea/button\n      const button = document.querySelector('.ai-review-button') as HTMLElement;\n      console.log('üîç Found AI button:', button);\n\n      const textarea = button ? findAssociatedTextarea(button) : null;\n      console.log('üéØ Found associated textarea:', textarea);\n\n      if (data && data.success && data.aiResponse && typeof data.aiResponse === 'string') {\n        // Success - insert the response\n        if (textarea) {\n          // Check current textarea content to avoid unnecessary overwrites\n          const currentValue = textarea.tagName === 'TEXTAREA' || textarea.tagName === 'INPUT'\n            ? (textarea as HTMLInputElement | HTMLTextAreaElement).value\n            : textarea.textContent || '';\n\n          console.log('üìù Inserting AI response into textarea via message listener:', {\n            responseLength: data.aiResponse.length,\n            currentTextareaLength: currentValue.length,\n            responsePreview: data.aiResponse.substring(0, 50) + '...'\n          });\n\n          // Only insert if the response has content or textarea is empty\n          if (data.aiResponse.length > 0 || currentValue.length === 0) {\n            insertGeneratedResponse(textarea, data.aiResponse);\n            console.log('‚úÖ AI response inserted via message listener');\n          } else {\n            console.log('‚è≠Ô∏è Skipping message listener insertion - response is empty and textarea has content');\n          }\n        } else {\n          console.log('‚ùå No textarea found to insert response into');\n        }\n\n        // Show success message\n        showSuccessMessage('AI response generated successfully!');\n\n        console.log('‚úÖ AI response inserted successfully');\n      } else {\n        // Error handling\n        console.error('‚ùå AI response failed:', data?.error || 'Unknown error');\n        if (textarea) {\n          hideLoadingState(textarea);\n        }\n        showErrorMessage(data?.error || 'Failed to generate AI response');\n      }\n    } catch (error) {\n      console.error('‚ùå Error handling AI response result:', error);\n      // Try to hide loading state even if there's an error\n      try {\n        const button = document.querySelector('.ai-review-button') as HTMLElement;\n        const textarea = button ? findAssociatedTextarea(button) : null;\n        if (textarea) {\n          hideLoadingState(textarea);\n        }\n      } catch (hideError) {\n        console.error('‚ùå Error hiding loading state:', hideError);\n      }\n      showErrorMessage('An unexpected error occurred while processing the response');\n    }\n  }\n\n  function handleProgressUpdate(data: any) {\n    console.log('üìä Handling progress update:', data);\n\n    try {\n      // Update button text to show progress\n      const button = document.querySelector('.ai-review-button') as HTMLElement;\n      if (button && data) {\n        const statusText = getStatusText(data.status);\n        const progressText = (typeof data.progress === 'number') ? ` (${data.progress}%)` : '';\n        button.textContent = `ü§ñ ${statusText}${progressText}`;\n      }\n    } catch (error) {\n      console.error('‚ùå Error updating progress:', error);\n    }\n  }\n\n  function getStatusText(status: string): string {\n    switch (status) {\n      case 'pending':\n        return 'Queued...';\n      case 'processing':\n        return 'Generating...';\n      case 'completed':\n        return 'Complete!';\n      case 'failed':\n        return 'Failed';\n      default:\n        return 'Processing...';\n    }\n  }\n\n  function showSuccessMessage(message: string) {\n    // Create a temporary success message\n    const successDiv = document.createElement('div');\n    successDiv.textContent = `‚úÖ ${message}`;\n    successDiv.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: #4caf50;\n      color: white;\n      padding: 12px 16px;\n      border-radius: 4px;\n      font-size: 14px;\n      z-index: 10000;\n      box-shadow: 0 2px 8px rgba(0,0,0,0.3);\n      max-width: 300px;\n    `;\n\n    document.body.appendChild(successDiv);\n\n    // Remove after 3 seconds\n    setTimeout(() => {\n      if (successDiv.parentNode) {\n        successDiv.remove();\n      }\n    }, 3000);\n  }\n\n  function findReviewText(): string {\n    console.log('üîç Searching for review text content');\n\n    // Try to extract review data using the provided selectors first\n    const reviewData = extractReviewData();\n    if (reviewData && reviewData.review_text) {\n      console.log('‚úÖ Found review text using provided selectors');\n      return reviewData.review_text;\n    }\n\n    // Fallback to legacy selectors if the new ones don't work\n    console.log('‚ö†Ô∏è Provided selectors failed, trying fallback selectors');\n\n    // Comprehensive selectors for finding review content\n    const reviewSelectors = [\n      // Google-specific selectors\n      '[data-review-text]',\n      '[data-message-text]',\n      '.review-text',\n      '.review-content',\n      '.review-body',\n      '[class*=\"review\"]',\n      // Generic content selectors\n      '[class*=\"content\"]',\n      '[class*=\"message\"]',\n      '[class*=\"comment\"]',\n      // Fallback to any text content in the main content area\n      'main [class*=\"text\"]',\n      'article [class*=\"text\"]',\n      '.main-content',\n      '#main-content'\n    ];\n\n    for (const selector of reviewSelectors) {\n      try {\n        const elements = document.querySelectorAll(selector);\n        for (const element of elements) {\n          if (element && element.textContent && element.textContent.trim().length > 20) {\n            const text = element.textContent.trim();\n            // Make sure it's not our button text or other UI text\n            if (!text.includes('Generate AI Reply') && !text.includes('Omitir') && !text.includes('Reply')) {\n              console.log(`‚úÖ Found review text using fallback selector: ${selector}`);\n              return text;\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(`‚ö†Ô∏è Error with selector ${selector}:`, error);\n      }\n    }\n\n    // Last resort: look for any substantial text content\n    const allTextElements = document.querySelectorAll('p, div, span');\n    for (const element of allTextElements) {\n      if (element.textContent && element.textContent.trim().length > 50) {\n        const text = element.textContent.trim();\n        if (!text.includes('Generate AI Reply') && !text.includes('Omitir')) {\n          console.log('‚úÖ Found review text using last resort search');\n          return text;\n        }\n      }\n    }\n\n    console.log('‚ö†Ô∏è No review text found, using default');\n    return 'Thank you for your valuable feedback. We appreciate you taking the time to share your experience with us.';\n  }\n\n  function extractReviewData() {\n    try {\n      console.log('üîç Extracting review data using provided selectors');\n\n      // Extract reviewer name using the provided selector\n      const reviewerNameElement = document.querySelector('#AH1dze > div > div > main > div > div > c-wiz > div > div > article > div.noyJyc > div > div > div.N0c6q.JhRJje') as HTMLElement;\n      const reviewer_name = reviewerNameElement?.textContent?.trim() || undefined;\n\n      // Extract rating from the star rating span - multiple fallback methods\n      let review_rating: number | undefined;\n\n      // Method 1: Try the specific Google Business rating span with DYizzd class\n      const ratingElement = document.querySelector('span.DYizzd[aria-label]') as HTMLElement;\n      if (ratingElement) {\n        const ariaLabel = ratingElement.getAttribute('aria-label') || '';\n        console.log('üéØ Found rating element with aria-label:', ariaLabel);\n\n        // Handle both Spanish and English formats, including non-breaking spaces\n        const match = ariaLabel.match(/(\\d+)\\s*(?:de|out of)\\s*5\\s*(?:estrellas?|stars?)/i);\n        if (match) {\n          review_rating = parseInt(match[1], 10);\n          console.log('‚úÖ Extracted rating from aria-label:', review_rating);\n        }\n      }\n\n      // Method 2: Fallback - count filled stars by checking for the filled star class\n      if (!review_rating && ratingElement) {\n        const filledStars = ratingElement.querySelectorAll('i.VfPpkd-kBDsod.lMAmUc:not(.VOmEhb)');\n        if (filledStars.length > 0) {\n          review_rating = filledStars.length;\n          console.log('‚úÖ Extracted rating by counting filled stars:', review_rating);\n        }\n      }\n\n      // Method 3: Alternative selector for older Google layouts\n      if (!review_rating) {\n        const altRatingElement = document.querySelector('span[aria-label*=\"de 5 estrellas\"], span[aria-label*=\"out of 5 stars\"]') as HTMLElement;\n        if (altRatingElement) {\n          const ariaLabel = altRatingElement.getAttribute('aria-label') || '';\n          const match = ariaLabel.match(/(\\d+)\\s*(?:de|out of)\\s*5/);\n          if (match) {\n            review_rating = parseInt(match[1], 10);\n            console.log('‚úÖ Extracted rating from alternative selector:', review_rating);\n          }\n        }\n      }\n\n      // Method 4: Look for any span with rating-like aria-label\n      if (!review_rating) {\n        const allRatingSpans = document.querySelectorAll('span[aria-label]');\n        for (const span of allRatingSpans) {\n          const ariaLabel = span.getAttribute('aria-label') || '';\n          const match = ariaLabel.match(/(\\d+)\\s*(?:de|out of|\\/)\\s*5\\s*(?:estrellas?|stars?)?/i);\n          if (match) {\n            review_rating = parseInt(match[1], 10);\n            console.log('‚úÖ Extracted rating from generic span search:', review_rating);\n            break;\n          }\n        }\n      }\n\n      // Method 5: Last resort - look for star icons and count them\n      if (!review_rating) {\n        const starIcons = document.querySelectorAll('i[aria-hidden=\"true\"]:not(.VOmEhb)');\n        if (starIcons.length > 0 && starIcons.length <= 5) {\n          review_rating = starIcons.length;\n          console.log('‚úÖ Extracted rating by counting star icons:', review_rating);\n        }\n      }\n\n      // Extract review text using the provided selector\n      const reviewTextElement = document.querySelector('div.gyKkFe.JhRJje.Fv38Af') as HTMLElement;\n      const extracted_text = reviewTextElement?.textContent?.trim();\n\n      // Handle empty reviews gracefully\n      let review_text: string;\n      if (!extracted_text || extracted_text.length === 0) {\n        // Empty review - provide a meaningful placeholder\n        review_text = \"[Review with no text content]\";\n        console.log('üìù Empty review detected, using placeholder text');\n        console.log('üîç Debug info:', {\n          extracted_text: extracted_text,\n          reviewer_name: reviewer_name,\n          review_rating: review_rating,\n          selector_found_element: !!reviewTextElement\n        });\n      } else {\n        review_text = extracted_text;\n      }\n\n      // Method 6: Default fallback - assume rating based on sentiment if still undefined\n      if (!review_rating) {\n        // If we have review text, try to infer sentiment\n        const hasPositiveWords = review_text && review_text !== \"[Review with no text content]\" && (\n          review_text.toLowerCase().includes('great') ||\n          review_text.toLowerCase().includes('excellent') ||\n          review_text.toLowerCase().includes('amazing') ||\n          review_text.toLowerCase().includes('love') ||\n          review_text.toLowerCase().includes('fantastic')\n        );\n\n        const hasNegativeWords = review_text && review_text !== \"[Review with no text content]\" && (\n          review_text.toLowerCase().includes('bad') ||\n          review_text.toLowerCase().includes('terrible') ||\n          review_text.toLowerCase().includes('worst') ||\n          review_text.toLowerCase().includes('disappointed') ||\n          review_text.toLowerCase().includes('awful')\n        );\n\n        if (hasPositiveWords && !hasNegativeWords) {\n          review_rating = 5;\n          console.log('‚úÖ Defaulted to 5 stars (positive sentiment detected)');\n        } else if (hasNegativeWords) {\n          review_rating = 1;\n          console.log('‚úÖ Defaulted to 1 star (negative sentiment detected)');\n        } else {\n          review_rating = 3;\n          console.log('‚úÖ Defaulted to 3 stars (neutral review)');\n        }\n      }\n\n      // Validate that we have basic review data (at minimum, we should have a rating or reviewer)\n      if (!reviewer_name && !review_rating && review_text === \"[Review with no text content]\") {\n        console.warn('‚ö†Ô∏è Review has no meaningful data (no reviewer, rating, or text)');\n        return null;\n      }\n\n      const reviewData = {\n        reviewer_name,\n        review_rating,\n        review_text,\n        website_url: window.location.href,\n        source_platform: 'Google'\n      };\n\n      console.log('‚úÖ Successfully extracted review data:', {\n        hasReviewer: !!reviewer_name,\n        rating: review_rating,\n        textLength: review_text ? review_text.length : 0,\n        url: reviewData.website_url,\n        ratingSource: review_rating ? 'extracted' : 'undefined',\n        reviewerSource: reviewer_name ? 'extracted' : 'undefined',\n        textSource: review_text !== \"[Review with no text content]\" ? 'extracted' : 'empty_review'\n      });\n\n      return reviewData;\n\n    } catch (error) {\n      console.error('‚ùå Error extracting review data:', error);\n      return null;\n    }\n  }\n\n  function generateReplyContent(reviewText: string): string {\n    // This is where you would integrate with your AI service\n    // For now, we'll generate a contextual response based on the review content\n\n    const lowerReview = reviewText.toLowerCase();\n\n    // Analyze sentiment and content\n    const isPositive = lowerReview.includes('great') || lowerReview.includes('excellent') || lowerReview.includes('amazing') || lowerReview.includes('love');\n    const isNegative = lowerReview.includes('bad') || lowerReview.includes('terrible') || lowerReview.includes('worst') || lowerReview.includes('disappointed');\n    const isSuggestion = lowerReview.includes('suggest') || lowerReview.includes('could') || lowerReview.includes('would be better');\n\n    if (isPositive) {\n      return `Thank you so much for your wonderful feedback! We're thrilled to hear that you're enjoying our service. Your positive experience means everything to us, and we look forward to serving you again soon!`;\n    } else if (isNegative) {\n      return `We're truly sorry to hear about your disappointing experience. Your feedback is incredibly valuable to us, and we're committed to improving our service. We'll review this carefully and work to ensure better experiences for all our customers.`;\n    } else if (isSuggestion) {\n      return `Thank you for your thoughtful suggestion! We truly appreciate you taking the time to share your ideas for improvement. Your feedback helps us enhance our service for everyone. We'll definitely consider implementing this.`;\n    } else {\n      return `Thank you for your feedback! We genuinely appreciate you taking the time to share your experience with us. Your input helps us continue to improve and provide the best possible service to all our customers.`;\n    }\n  }\n\n  // ==================== CLEANUP AND MEMORY MANAGEMENT ====================\n\n  function cleanup() {\n    console.log('üßπ Performing cleanup of dynamic injection system');\n\n    // Clear intervals\n    if (urlCheckInterval) {\n      clearInterval(urlCheckInterval);\n      urlCheckInterval = null;\n      console.log('‚úÖ URL monitoring interval cleared');\n    }\n\n    // Clear debounce timer\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n      debounceTimer = null;\n      console.log('‚úÖ Debounce timer cleared');\n    }\n\n    // Disconnect mutation observer\n    if (mutationObserver) {\n      mutationObserver.disconnect();\n      mutationObserver = null;\n      console.log('‚úÖ MutationObserver disconnected');\n    }\n\n    // Disconnect button observer\n    if (buttonObserver) {\n      buttonObserver.disconnect();\n      buttonObserver = null;\n      console.log('‚úÖ Button Observer disconnected');\n    }\n\n    // Clear injected buttons set\n    injectedButtons.clear();\n    console.log('‚úÖ Injected buttons set cleared');\n\n    console.log('üßπ Cleanup complete');\n  }\n\n  // Cleanup on page unload\n  window.addEventListener('beforeunload', cleanup);\n  window.addEventListener('unload', cleanup);\n\n  // Cleanup on iframe navigation (in case iframe is reused)\n  window.addEventListener('pagehide', cleanup);\n\n  // Periodic health check\n  setInterval(() => {\n    console.log('üíì System health check:', {\n      urlMonitoring: urlCheckInterval !== null,\n      mutationObserver: mutationObserver !== null,\n      buttonObserver: buttonObserver !== null,\n      injectedButtons: injectedButtons.size,\n      isInjecting: isInjecting,\n      debounceActive: debounceTimer !== null,\n      lastInjectionTime: new Date(lastInjectionTime).toISOString()\n    });\n  }, 30000); // Every 30 seconds\n\n  console.log('üéâ Dynamic AI Button Injection System fully initialized and ready!');\n\n  // ==================== LEGACY MONITORING (KEPT FOR BACKWARD COMPATIBILITY) ====================\n\n  function monitorForReplyNavigation() {\n    console.log('üëÅÔ∏è Legacy monitoring called - redirecting to dynamic system');\n    // This is now handled by the dynamic injection system\n    initializeDynamicInjectionSystem();\n  }\n\n})();\n"],"names":["console","log","window","location","href","lastKnownUrl","mutationObserver","urlCheckInterval","injectedButtons","Set","buttonObserver","debounceTimer","lastInjectionTime","isInjecting","parent","postMessage","type","data","url","timestamp","Date","toISOString","chrome","runtime","onMessage","addListener","message","sender","sendResponse","button","document","querySelector","textarea","findAssociatedTextarea","success","aiResponse","currentValue","tagName","value","textContent","responseLength","length","currentTextareaLength","responsePreview","substring","insertGeneratedResponse","successDiv","createElement","style","cssText","body","appendChild","setTimeout","parentNode","remove","showSuccessMessage","error","hideLoadingState","showErrorMessage","hideError","handleAIResponseResult","statusText","status","getStatusText","progressText","progress","handleProgressUpdate","currentUrl","hasCustomersReviews","includes","isSingleReviewReply","debouncedInjectAIButtons","timeSinceLastInjection","now","clearTimeout","remainingTime","performInjection","cleanupOrphanedButtons","textareas","specificSelector","foundTextareas","element","hasAttribute","getAttribute","placeholder","hasReplyKeyword","some","keyword","toLowerCase","isInForm","closest","isLikelyReplyTextarea","hasAssociatedButton","id","jsname","push","className","isContentEditable","warn","findAllReplyTextareas","successfulInjections","skippedInjections","forEach","index","findExistingButtonForTextarea","setAttribute","onmouseover","backgroundColor","onmouseout","addEventListener","e","preventDefault","stopPropagation","replyElement","hasContentEditable","reviewData","reviewerNameElement","reviewer_name","trim","undefined","review_rating","ratingElement","ariaLabel","match","parseInt","filledStars","querySelectorAll","altRatingElement","allRatingSpans","span","starIcons","reviewTextElement","extracted_text","review_text","selector_found_element","hasPositiveWords","hasNegativeWords","website_url","source_platform","hasReviewer","rating","textLength","ratingSource","reviewerSource","textSource","extractReviewData","reviewer","isEmptyReview","opacity","pointerEvents","originalPlaceholder","showLoadingState","sendMessage","mode","response","replyLength","reviewTextLength","confidence","processingTime","tokensUsed","generateAIReply","innerHTML","createAIButton","injectionPoint","googleContainer","skipButton","container","reference","anyButton","form","buttonContainer","firstElementChild","parentElement","nextElementSibling","findBestInjectionPoint","insertBefore","textareaIdentifier","toString","injectButtonAtPoint","add","injectAIButtonForTextarea","found","successful","skipped","totalButtons","size","textareaId","allButtons","existingButtons","cleanedCount","associatedJsname","injectionTimestamp","textareaExists","contains","buttonAge","Math","round","delete","googleReplyTextarea","previousTextarea","previousElementSibling","anyTextarea","has","containerSelectors","selector","currentElement","i","removeAttribute","dispatchEvent","Event","bubbles","focus","errorDiv","cleanup","clearInterval","disconnect","clear","fullUrl","pattern","setInterval","from","to","MutationObserver","mutations","shouldTriggerScan","relevantChanges","mutation","addedNodes","node","nodeType","Node","ELEMENT_NODE","matches","removedNodes","Array","target","attributeName","changes","observe","childList","subtree","attributes","attributeFilter","classList","urlMonitoring","debounceActive"],"sourceRoot":""}