{"version":3,"file":"content/iframe-script.js","mappings":"mBAIA,MAEE,IAAIA,EAAeC,OAAOC,SAASC,KAC/BC,EAA4C,KAC5CC,EAAkC,KAClCC,EAAoC,IAAIC,IACxCC,EAA0C,KAC1CC,EAA+B,KAC/BC,EAAoB,EACpBC,GAAc,EAKdV,OAAOW,QAAUX,OAAOW,SAAWX,QACrCA,OAAOW,OAAOC,YAAY,CACxBC,KAAM,eACNC,KAAM,CACJC,IAAKf,OAAOC,SAASC,KACrBc,WAAW,IAAIC,MAAOC,gBAEvB,KAILC,OAAOC,QAAQC,UAAUC,YAAY,CAACC,EAASC,EAAQC,KACrD,OAAQF,EAAQV,MACd,IAAK,sBA0sBT,SAAgCC,GAC9B,IAEE,MAAMY,EAASC,SAASC,cAAc,qBAEhCC,EAAWH,EAASI,EAAuBJ,GAAU,KAE3D,GAAIZ,GAAQA,EAAKiB,SAAWjB,EAAKkB,YAAyC,iBAApBlB,EAAKkB,WAAyB,CAElF,GAAIH,EAAU,CAEZ,MAAMI,EAAoC,aAArBJ,EAASK,SAA+C,UAArBL,EAASK,QAC5DL,EAAoDM,MACrDN,EAASO,aAAe,IAGxBtB,EAAKkB,WAAWK,OAAS,GAA6B,IAAxBJ,EAAaI,SAC7CC,EAAwBT,EAAUf,EAAKkB,WAE3C,EAyDN,WAEE,MAAMO,EAAaZ,SAASa,cAAc,OAC1CD,EAAWH,YAAc,wCACzBG,EAAWE,MAAMC,QAAU,8XAgB3Bf,SAASgB,KAAKC,YAAYL,GAG1BM,WAAW,KACLN,EAAWO,YACbP,EAAWQ,UAEZ,IACL,CAlFMC,EACF,MAEEC,QAAQC,MAAM,wBAAyBpC,GAAMoC,OAAS,iBAClDrB,GACFsB,EAAiBtB,GAEnBuB,EAAiBtC,GAAMoC,OAAS,iCAEpC,CAAE,MAAOA,GACPD,QAAQC,MAAM,uCAAwCA,GAEtD,IACE,MAAMxB,EAASC,SAASC,cAAc,qBAChCC,EAAWH,EAASI,EAAuBJ,GAAU,KACvDG,GACFsB,EAAiBtB,EAErB,CAAE,MAAOwB,GACPJ,QAAQC,MAAM,gCAAiCG,EACjD,CACAD,EAAiB,6DACnB,CACF,CAtvBME,CAAuB/B,EAAQT,MAC/B,MAEF,IAAK,mBAqvBT,SAA8BA,GAC5B,IAEE,MAAMY,EAASC,SAASC,cAAc,qBACtC,GAAIF,GAAUZ,EAAM,CAClB,MAAMyC,EASZ,SAAuBC,GACrB,OAAQA,GACN,IAAK,UACH,MAAO,YACT,IAAK,aACH,MAAO,gBACT,IAAK,YACH,MAAO,YACT,IAAK,SACH,MAAO,SACT,QACE,MAAO,gBAEb,CAtByBC,CAAc3C,EAAK0C,QAChCE,EAAyC,iBAAlB5C,EAAK6C,SAAyB,KAAK7C,EAAK6C,aAAe,GACpFjC,EAAOU,YAAc,MAAMmB,IAAaG,GAC1C,CACF,CAAE,MAAOR,GACPD,QAAQC,MAAM,6BAA8BA,EAC9C,CACF,CAhwBMU,CAAqBrC,EAAQT,MAIjCW,EAAa,CAAEM,SAAS,MAI1B,MAAM8B,EAAa7D,OAAOC,SAASC,KAC7B4D,EAAsBD,EAAWE,SAAS,sBAmJhD,SAASC,IACP,MACMC,EADMhD,KAAKiD,MACoBzD,EAQrC,GALID,IACF2D,aAAa3D,GACbA,EAAgB,MAGdyD,EA5LwB,IA4LwB,CAClD,MAAMG,EA7LoB,IA6LoBH,EAE9CzD,EAAgBR,OAAO6C,WAAW,KAChCwB,IACA7D,EAAgB,MACf4D,EAEL,MACEC,GAEJ,CAEA,SAASA,IAEP,IAAI3D,EAAJ,CAIAA,GAAc,EACdD,EAAoBQ,KAAKiD,MAEzB,IAEEI,IAGA,MAAMC,EAwBV,WAEE,MACMC,EAAwC,GAE9C,IACE,MAAMC,EAAU9C,SAASC,cAJF,qBAMnB6C,IAAgC,aAApBA,EAAQvC,SAA0BuC,EAAQC,aAAa,qBAa3E,SAA+BD,GAK7B,GAAwB,aAApBA,EAAQvC,UAA2BuC,EAAQC,aAAa,mBAC1D,OAAO,EAIT,GAAuC,WAAnCD,EAAQE,aAAa,UACvB,OAAO,EAIT,MAAMC,EAAeH,EAAmDG,aAAeH,EAAQE,aAAa,qBAAuB,GAG7HE,EAFW,CAAC,QAAS,UAAW,UAAW,YAEhBC,KAAKC,GACpCH,EAAYI,cAAcjB,SAASgB,IAI/BE,EAAuC,OAA5BR,EAAQS,QAAQ,QAGjC,OAAOL,GAAmBI,GAA+C,WAAnCR,EAAQE,aAAa,SAC7D,CAtCUQ,CAAsBV,KAwChC,SAA6B5C,GAE3B,MAAMuD,EAASvD,EAAS8C,aAAa,UAGrC,GAFmB9C,EAASwD,GAExBD,EAAQ,CAEV,MAAME,EAAa3D,SAAS4D,iBAAiB,qBAC7C,IAAK,MAAM7D,KAAU4D,EAEnB,GADqB5D,EAAOiD,aAAa,4BACpBS,EACnB,OAAO,CAGb,CAGA,MAAMI,EAAY3D,EAASqD,QAAQ,mDAAqDrD,EAAS4D,cACjG,SAAID,IACmBA,EAAU5D,cAAc,qBAOjD,CAlE6C8D,CAAoBjB,IACzDD,EAAemB,KAAKlB,EAG1B,CAAE,MAAOvB,GAET,CAEA,OAAOsB,CACT,CA3CsBoB,GAElB,GAAIrB,EAAUlC,OAAS,EAAG,CACxB,IAAIwD,EAAuB,EACvBC,EAAoB,EAExBvB,EAAUwB,QAAQ,CAAClE,EAAUmE,KAE3B,GADuBC,EAA8BpE,GAEnDiE,QACK,CACL,MAAM/D,EAkKhB,SAAmCF,EAAuBmE,GAIxD,GAFuBC,EAA8BpE,GAGnD,OAAO,EAGT,IACE,MAAMH,EAgEV,SAAwBG,GACtB,MAAMH,EAASC,SAASa,cAAc,UA8CtC,OA7CAd,EAAOU,YAAc,aACrBV,EAAOwE,UAAY,yHACnBxE,EAAOyE,aAAa,mBAAoBtE,EAASwD,IAAM,YAAcpE,KAAKiD,OAE1ExC,EAAOe,MAAMC,QAAU,wfAoBvBhB,EAAO0E,YAAc,IAAM1E,EAAOe,MAAM4D,gBAAkB,qBAC1D3E,EAAO4E,WAAa,IAAM5E,EAAOe,MAAM4D,gBAAkB,qBAGzD3E,EAAO6E,iBAAiB,QAAUC,IAChCA,EAAEC,iBACFD,EAAEE,kBA2FN,SAAyBC,GACvB,IAEE,MAAMC,EAsTV,WACE,IAEE,MAAMC,EAAsBlF,SAASC,cAAc,oHAC7CkF,EAAgBD,GAAqBzE,aAAa2E,aAAUC,EAGlE,IAAIC,EAGJ,MAAMC,EAAgBvF,SAASC,cAAc,2BAC7C,GAAIsF,EAAe,CACjB,MAGMC,GAHYD,EAAcvC,aAAa,eAAiB,IAGtCwC,MAAM,sDAC1BA,IACFF,EAAgBG,SAASD,EAAM,GAAI,IAEvC,CAGA,IAAKF,GAAiBC,EAAe,CACnC,MAAMG,EAAcH,EAAc3B,iBAAiB,uCAC/C8B,EAAYhF,OAAS,IACvB4E,EAAgBI,EAAYhF,OAEhC,CAGA,IAAK4E,EAAe,CAClB,MAAMK,EAAmB3F,SAASC,cAAc,0EAChD,GAAI0F,EAAkB,CACpB,MACMH,GADYG,EAAiB3C,aAAa,eAAiB,IACzCwC,MAAM,6BAC1BA,IACFF,EAAgBG,SAASD,EAAM,GAAI,IAEvC,CACF,CAGA,IAAKF,EAAe,CAClB,MAAMM,EAAiB5F,SAAS4D,iBAAiB,oBACjD,IAAK,MAAMiC,KAAQD,EAAgB,CACjC,MACMJ,GADYK,EAAK7C,aAAa,eAAiB,IAC7BwC,MAAM,0DAC9B,GAAIA,EAAO,CACTF,EAAgBG,SAASD,EAAM,GAAI,IACnC,KACF,CACF,CACF,CAGA,IAAKF,EAAe,CAClB,MAAMQ,EAAY9F,SAAS4D,iBAAiB,sCACxCkC,EAAUpF,OAAS,GAAKoF,EAAUpF,QAAU,IAC9C4E,EAAgBQ,EAAUpF,OAE9B,CAGA,MAAMqF,EAAoB/F,SAASC,cAAc,4BAC3C+F,EAAiBD,GAAmBtF,aAAa2E,OAGvD,IAAIa,EASJ,GAJEA,EAJGD,GAA4C,IAA1BA,EAAetF,OAItBsF,EAFA,iCAMXV,EAAe,CAElB,MAAMY,EAAmBD,GAA+B,kCAAhBA,IACtCA,EAAY5C,cAAcjB,SAAS,UACnC6D,EAAY5C,cAAcjB,SAAS,cACnC6D,EAAY5C,cAAcjB,SAAS,YACnC6D,EAAY5C,cAAcjB,SAAS,SACnC6D,EAAY5C,cAAcjB,SAAS,cAG/B+D,EAAmBF,GAA+B,kCAAhBA,IACtCA,EAAY5C,cAAcjB,SAAS,QACnC6D,EAAY5C,cAAcjB,SAAS,aACnC6D,EAAY5C,cAAcjB,SAAS,UACnC6D,EAAY5C,cAAcjB,SAAS,iBACnC6D,EAAY5C,cAAcjB,SAAS,UAInCkD,EADEY,IAAqBC,EACP,EACPA,EACO,EAEA,CAEpB,CAGA,OAAKhB,GAAkBG,GAAiC,kCAAhBW,EAIrB,CACjBd,gBACAG,gBACAW,cACAG,YAAa/H,OAAOC,SAASC,KAC7B8H,gBAAiB,UARV,IAaX,CAAE,MAAO9E,GAEP,OADAD,QAAQC,MAAM,kCAAmCA,GAC1C,IACT,CACF,CAhbuB+E,GACnB,IAAKrB,EAGH,OAFA3D,QAAQC,MAAM,wCACdE,EAAiB,qDAyDvB,SAA0BuD,GAExB,MAAMjF,EAASC,SAASC,cAAc,qBACtC,GAAIF,EAAQ,CACV,MAAMwG,EAAgB,4KACtBxG,EAAOyG,UAAY,+DAA+DD,yBAClFxG,EAAOe,MAAM2F,QAAU,MACvB1G,EAAOe,MAAM4F,cAAgB,MAC/B,CAGA,GAAI1B,EAAajC,aAAa,eAAgB,CAC5C,MAAM4D,EAAsB3B,EAAahC,aAAa,gBAAkB,GACxEgC,EAAaR,aAAa,4BAA6BmC,GACvD3B,EAAaR,aAAa,cAAe,4BAC3C,CACF,CApEIoC,CAAiB5B,GAGjBxF,OAAOC,QAAQoH,YAAY,CACzB3H,KAAM,uBACNC,KAAM,CACJ8F,WAAYA,IAEZ6B,IACF,GAAIA,GAAYA,EAAS1G,QAAS,CAEhC,MAAMC,EAAayG,EAASzG,YAAc,GAIpCC,EAAwC,aAAzB0E,EAAazE,SAAmD,UAAzByE,EAAazE,QACpEyE,EAAwDxE,MACzDwE,EAAavE,aAAe,IAE5BJ,EAAWK,OAAS,GAA6B,IAAxBJ,EAAaI,SACxCC,EAAwBqE,EAAc3E,GAIpChC,OAAOW,QAAUX,OAAOW,SAAWX,QACrCA,OAAOW,OAAOC,YAAY,CACxBC,KAAM,kBACNC,KAAM,CACJ4H,YAAa1G,EAAWK,OACxBsG,iBAAkB/B,EAAWgB,YAAchB,EAAWgB,YAAYvF,OAAS,EAC3EuG,WAAYH,EAASG,WACrBC,eAAgBJ,EAASI,eACzBC,WAAYL,EAASK,WACrB9H,WAAW,IAAIC,MAAOC,gBAEvB,IAEP,MAEE+B,QAAQC,MAAM,kCAAmCuF,GAAUvF,OAC3DE,EAAiBqF,GAAUvF,OAAS,kCACpCC,EAAiBwD,IAIvB,CAAE,MAAOzD,GACPD,QAAQC,MAAM,8BAA+BA,GAC7CE,EAAiB,mDACjBD,EAAiBwD,EACnB,CACF,CAvJIoC,CAAgBlH,KAOlBH,EAAOyG,UAAY,gbAOZzG,CACT,CAhHmBsH,CAAenH,GACxBoH,EAiHV,SAAgCpH,GAE9B,MAAMqH,EAAkBvH,SAASC,cAAc,0BAC/C,GAAIsH,EAAiB,CACnB,MAAMC,EAAaD,EAAgBtH,cAAc,2BACjD,GAAIuH,EACF,MAAO,CAAE3D,UAAW0D,EAAiBE,UAAWD,GAGlD,MAAME,EAAYH,EAAgBtH,cAAc,UAChD,GAAIyH,EACF,MAAO,CAAE7D,UAAW0D,EAAiBE,UAAWC,EAEpD,CAGA,MAAMC,EAAOzH,EAASqD,QAAQ,QAC9B,GAAIoE,EAAM,CACR,MAAMC,EAAkBD,EAAK1H,cAAc,8CAC3C,GAAI2H,EACF,MAAO,CAAE/D,UAAW+D,EAAiBH,UAAWG,EAAgBC,kBAEpE,CAGA,OAAI3H,EAAS4D,cACJ,CAAED,UAAW3D,EAAS4D,cAAe2D,UAAWvH,EAAS4H,oBAG3D,IACT,CA/I2BC,CAAuB7H,GAE9C,QAAIoH,IA+IR,SAA6BvH,EAAqBuH,EAA2EpH,GACvHoH,EAAeG,UAEjBH,EAAezD,UAAUmE,aAAajI,EAAQuH,EAAeG,WAG7DH,EAAezD,UAAU5C,YAAYlB,GAIvC,MAAMkI,EAAqB/H,EAAS8C,aAAa,WAAa9C,EAASwD,IAAM,qBAC7E3D,EAAOyE,aAAa,2BAA4ByD,GAChDlI,EAAOyE,aAAa,yBAA0BtE,EAAS8C,aAAa,WAAa,IACjFjD,EAAOyE,aAAa,2BAA4BlF,KAAKiD,MAAM2F,WAC7D,CA5JMC,CAAoBpI,EAAQuH,EAAgBpH,GAC5CxB,EAAgB0J,IAAIrI,IACb,EAIX,CAAE,MAAOwB,GAEP,OADAD,QAAQC,MAAM,0CAA0C8C,EAAQ,KAAM9C,IAC/D,CACT,CACF,CAzL0B8G,CAA0BnI,EAAUmE,GAChDjE,GACF8D,GAEJ,GAEJ,CACF,C,QAEEnF,GAAc,CAChB,CA/BA,CAgCF,CAgFA,SAAS4D,IACiB3C,SAAS4D,iBAAiB,qBAGlCQ,QAAQrE,IACtB,MAAMuI,EAAmBvI,EAAOiD,aAAa,0BACvCuF,EAAqBxI,EAAOiD,aAAa,4BAG/C,IAAIwF,GAAiB,EACrB,GAAIF,EAAkB,CACpB,MAAMpI,EAAWF,SAASC,cAAc,YAAYqI,OACpDE,EAA8B,OAAbtI,GAAqBF,SAASyI,SAASvI,EAC1D,CAGKsI,EAQID,GACWjJ,KAAKiD,MAAQkD,SAAS8C,GACJ,MAGlCxI,EAAOqB,SACP1C,EAAgBgK,OAAO3I,KAbrBA,EAAOoB,YACTpB,EAAOqB,SAET1C,EAAgBgK,OAAO3I,KAe7B,CAEA,SAASI,EAAuBJ,GAE9B,MAAM4I,EAAsB3I,SAASC,cAAc,8BACxBD,SAASC,cAAc,qBAClD,GAAI0I,EACF,OAAOA,EAIT,MAAM9E,EAAY9D,EAAO+D,cACzB,GAAID,EAAW,CACb,MAAM3D,EAAW2D,EAAU5D,cAAc,aACzB4D,EAAU5D,cAAc,4BACxC,GAAIC,EACF,OAAOA,CAEX,CAGA,MAAM0I,EAAmB7I,EAAO+D,eAAe+E,wBAAwB5I,cAAc,aAC9DF,EAAO+D,eAAe+E,wBAAwB5I,cAAc,4BACnF,GAAI2I,EACF,OAAOA,EAKT,OADoB5I,SAASC,cAAc,aAKpC,IACT,CA2BA,SAASqE,EAA8BpE,GAIrC,MAAM4I,EAAa5I,EAASwD,IAAMxD,EAAS8C,aAAa,WAAa,qBAC/DW,EAAa3D,SAAS4D,iBAAiB,qBAE7C,IAAK,MAAM7D,KAAU4D,EAEnB,GADyB5D,EAAOiD,aAAa,8BACpB8F,GAAcpK,EAAgBqK,IAAIhJ,GACzD,OAAOA,EAKX,MAAMiJ,EAAqB,CACzB,0BACA,cACA,OACA,SACA,UACA,eACA,iBAGF,IAAK,MAAMC,KAAYD,EAAoB,CACzC,MAAMnF,EAAY3D,EAASqD,QAAQ0F,GACnC,GAAIpF,EAAW,CACb,MAAM9D,EAAS8D,EAAU5D,cAAc,qBACvC,GAAIF,GAAUrB,EAAgBqK,IAAIhJ,GAChC,OAAOA,CAEX,CACF,CAGA,IAAImJ,EAAqChJ,EACzC,IAAK,IAAIiJ,EAAI,EAAGA,EAAI,GAAKD,EAAgBC,IAAK,CAC5C,MAAMpJ,EAASmJ,EAAejJ,cAAc,qBAC5C,GAAIF,GAAUrB,EAAgBqK,IAAIhJ,GAChC,OAAOA,EAETmJ,EAAiBA,EAAepF,aAClC,CAEA,OAAO,IACT,CA8MA,SAAStC,EAAiBwD,GAExB,MAAMjF,EAASC,SAASC,cAAc,qBACtC,GAAIF,EAAQ,CACV,MAAMwG,EAAgB,4KACtBxG,EAAOyG,UAAY,+DAA+DD,sBAClFxG,EAAOe,MAAM2F,QAAU,IACvB1G,EAAOe,MAAM4F,cAAgB,MAC/B,CAGA,GAAI1B,EAAajC,aAAa,6BAA8B,CAC1D,MAAM4D,EAAsB3B,EAAahC,aAAa,8BAAgC,GACtFgC,EAAaR,aAAa,cAAemC,GACzC3B,EAAaoE,gBAAgB,4BAC/B,CACF,CAEA,SAASzI,EAAwBqE,EAA2B8B,GAC1DtF,EAAiBwD,GAGY,aAAzBA,EAAazE,SAAmD,UAAzByE,EAAazE,SACrDyE,EAAwDxE,MAAQsG,EAEjE9B,EAAaqE,cAAc,IAAIC,MAAM,QAAS,CAAEC,SAAS,MAChDvE,EAAajC,aAAa,qBACnCiC,EAAavE,YAAcqG,EAE3B9B,EAAaqE,cAAc,IAAIC,MAAM,QAAS,CAAEC,SAAS,MAI3DvE,EAAawE,OACf,CAEA,SAAS/H,EAAiB7B,GAExB,MAAM6J,EAAWzJ,SAASa,cAAc,OACxC4I,EAAShJ,YAAc,KAAKb,IAC5B6J,EAAS3I,MAAMC,QAAU,4XAgBzBf,SAASgB,KAAKC,YAAYwI,GAG1BvI,WAAW,KACLuI,EAAStI,YACXsI,EAASrI,UAEV,IACL,CA4TA,SAASsI,IAEHjL,IACFkL,cAAclL,GACdA,EAAmB,MAIjBI,IACF2D,aAAa3D,GACbA,EAAgB,MAIdL,IACFA,EAAiBoL,aACjBpL,EAAmB,MAIjBI,IACFA,EAAegL,aACfhL,EAAiB,MAInBF,EAAgBmL,OAClB,CAhhC4B3H,EAAWE,SAAS,4BAE5CD,IAqBF1D,EAAmBJ,OAAOyL,YAAY,KACpC,MAAM5H,EAAa7D,OAAOC,SAASC,KAE/B2D,IAAe9D,IACjBA,EAAe8D,EA6GnBS,MAvK4B,KAiE5BnE,EAAmB,IAAIuL,iBAAkBC,IACvC,IAAIC,GAAoB,EACpBC,EAA4B,GAEhCF,EAAU5F,QAAQ+F,IACM,cAAlBA,EAASjL,MAEXiL,EAASC,WAAWhG,QAAQiG,IAC1B,GAAIA,EAAKC,WAAaC,KAAKC,aAAc,CACvC,MAAM1H,EAAUuH,GACZvH,EAAQ2H,QAAQ,sBAChB3H,EAAQ7C,cAAc,wBACxBgK,GAAoB,EACpBC,EAAgBlG,KAAK,kBAEzB,IAGFmG,EAASO,aAAatG,QAAQiG,IAC5B,GAAIA,EAAKC,WAAaC,KAAKC,aAAc,CACvC,MAAM1H,EAAUuH,GACZvH,EAAQ2H,QAAQ,sBAChB3H,EAAQ7C,cAAc,wBACxBgK,GAAoB,EACpBC,EAAgBlG,KAAK,oBAEzB,KAIGiG,IAAsBE,EAASC,WAAW1J,OAAS,GAAKyJ,EAASO,aAAahK,OAAS,IAE7DiK,MAAMC,KAAKT,EAASC,YAAYjH,KAAKkH,IAChE,GAAIA,EAAKC,WAAaC,KAAKC,aAAc,CACvC,MAAM1H,EAAUuH,EAChB,OAAOvH,EAAQ2H,QAAQ,gEAChB3H,EAAQ7C,cAAc,8DAC/B,CACA,OAAO,MAIPgK,GAAoB,EACpBC,EAAgBlG,KAAK,uBAGE,eAAlBmG,EAASjL,MAEdiL,EAASU,OAAOP,WAAaC,KAAKC,cACpBL,EAASU,OACbJ,QAAQ,sBAChB,CAAC,KAAM,QAAS,cAAe,UAAUrI,SAAS+H,EAASW,eAAiB,MAC9Eb,GAAoB,EACpBC,EAAgBlG,KAAK,iCAMzBiG,GAkDN5H,MA5CA7D,EAAiBuM,QAAQ/K,SAASgB,KAAM,CACtCgK,WAAW,EACXC,SAAS,EACTC,YAAY,EACZC,gBAAiB,CAAC,KAAM,QAAS,cAAe,YAvFlD9I,IA4FAzD,EAAiB,IAAImL,iBAAkBC,IACrCA,EAAU5F,QAAQ+F,IACM,cAAlBA,EAASjL,MACXiL,EAASO,aAAatG,QAAQiG,IAC5B,GAAIA,EAAKC,WAAaC,KAAKC,aAAc,CACvC,MAAM1H,EAAUuH,EACZvH,EAAQsI,UAAU3C,SAAS,qBAC7B/J,EAAgBgK,OAAO5F,GAGFA,EAAQc,iBAAiB,qBACjCQ,QAAQrE,IACrBrB,EAAgBgK,OAAO3I,IAE3B,QAORnB,EAAemM,QAAQ/K,SAASgB,KAAM,CACpCgK,WAAW,EACXC,SAAS,KAg5Bb5M,OAAOuG,iBAAiB,eAAgB8E,GAGxCrL,OAAOuG,iBAAiB,WAAY8E,GAGpCI,YAAY,OAET,IASJ,EA9kCD,E","sources":["webpack://chrome-extension-ai-review-replier/./src/content/iframe-script.ts"],"sourcesContent":["// AI Review Responder - Dynamic Iframe Script\n// This script runs ONLY in Google Business review iframes (automatically injected by manifest.json)\n// URL pattern: https://www.google.com/local/business/*/customers/reviews*\n\n(() => {\n  // Global state for dynamic injection system\n  let lastKnownUrl = window.location.href;\n  let mutationObserver: MutationObserver | null = null;\n  let urlCheckInterval: number | null = null;\n  let injectedButtons: Set<HTMLElement> = new Set();\n  let buttonObserver: MutationObserver | null = null; // Track button removal\n  let debounceTimer: number | null = null;\n  let lastInjectionTime = 0;\n  let isInjecting = false; // Prevent concurrent injections\n  const INJECTION_DEBOUNCE_MS = 1000; // Prevent rapid re-injection\n  const URL_CHECK_INTERVAL_MS = 500;\n\n  // Notify parent frame that iframe script is ready\n  if (window.parent && window.parent !== window) {\n    window.parent.postMessage({\n      type: 'IFRAME_READY',\n      data: {\n        url: window.location.href,\n        timestamp: new Date().toISOString()\n      }\n    }, '*');\n  }\n\n  // Listen for messages from background script (for progress updates, etc.)\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    switch (message.type) {\n      case 'AI_RESPONSE_RESULT':\n        handleAIResponseResult(message.data);\n        break;\n\n      case 'PROGRESS_UPDATE':\n        handleProgressUpdate(message.data);\n        break;\n    }\n\n    sendResponse({ success: true });\n  });\n\n  // Determine if this is a single review reply iframe or multi-review iframe\n  const currentUrl = window.location.href;\n  const hasCustomersReviews = currentUrl.includes('/customers/reviews');\n  const isSingleReviewReply = currentUrl.includes('/customers/reviews/reply');\n\n  if (hasCustomersReviews) {\n    initializeDynamicInjectionSystem();\n  }\n\n  // ==================== DYNAMIC INJECTION SYSTEM ====================\n\n  function initializeDynamicInjectionSystem() {\n    // Set up content change detection\n    setupContentChangeDetection();\n\n    // Set up DOM mutation monitoring\n    setupMutationObserver();\n\n    // Initial scan for existing textareas\n    debouncedInjectAIButtons();\n\n    // Set up button removal observer\n    setupButtonObserver();\n  }\n\n  function setupContentChangeDetection() {\n    urlCheckInterval = window.setInterval(() => {\n      const currentUrl = window.location.href;\n\n      if (currentUrl !== lastKnownUrl) {\n        lastKnownUrl = currentUrl;\n        handleContentChange();\n      }\n    }, URL_CHECK_INTERVAL_MS);\n  }\n\n  function setupMutationObserver() {\n    mutationObserver = new MutationObserver((mutations) => {\n      let shouldTriggerScan = false;\n      let relevantChanges: string[] = [];\n\n      mutations.forEach(mutation => {\n        if (mutation.type === 'childList') {\n          // Check for our specific textarea (jsname=\"YPqjbf\") being added or removed\n          mutation.addedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              const element = node as Element;\n              if (element.matches('[jsname=\"YPqjbf\"]') ||\n                  element.querySelector('[jsname=\"YPqjbf\"]')) {\n                shouldTriggerScan = true;\n                relevantChanges.push('textarea_added');\n              }\n            }\n          });\n\n          mutation.removedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              const element = node as Element;\n              if (element.matches('[jsname=\"YPqjbf\"]') ||\n                  element.querySelector('[jsname=\"YPqjbf\"]')) {\n                shouldTriggerScan = true;\n                relevantChanges.push('textarea_removed');\n              }\n            }\n          });\n\n          // Also check for significant structural changes that might affect our textarea\n          if (!shouldTriggerScan && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {\n            // Look for changes in form containers or review-related elements\n            const hasStructuralChanges = Array.from(mutation.addedNodes).some(node => {\n              if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node as Element;\n                return element.matches('form, .modal, .dialog, .review-reply-container, .reply-form') ||\n                       element.querySelector('form, .modal, .dialog, .review-reply-container, .reply-form');\n              }\n              return false;\n            });\n\n            if (hasStructuralChanges) {\n              shouldTriggerScan = true;\n              relevantChanges.push('structural_change');\n            }\n          }\n        } else if (mutation.type === 'attributes') {\n          // Check if our specific textarea's attributes changed\n          if (mutation.target.nodeType === Node.ELEMENT_NODE) {\n            const element = mutation.target as Element;\n            if (element.matches('[jsname=\"YPqjbf\"]') &&\n                ['id', 'class', 'placeholder', 'jsname'].includes(mutation.attributeName || '')) {\n              shouldTriggerScan = true;\n              relevantChanges.push('textarea_attribute_changed');\n            }\n          }\n        }\n      });\n\n      if (shouldTriggerScan) {\n        handleTextareaChanges();\n      }\n    });\n\n    // Start observing with more targeted configuration\n    mutationObserver.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['id', 'class', 'placeholder', 'jsname']\n    });\n  }\n\n  function setupButtonObserver() {\n    buttonObserver = new MutationObserver((mutations) => {\n      mutations.forEach(mutation => {\n        if (mutation.type === 'childList') {\n          mutation.removedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              const element = node as Element;\n              if (element.classList.contains('ai-review-button')) {\n                injectedButtons.delete(element as HTMLElement);\n              }\n              // Also check for buttons inside removed containers\n              const removedButtons = element.querySelectorAll('.ai-review-button');\n              removedButtons.forEach(button => {\n                injectedButtons.delete(button as HTMLElement);\n              });\n            }\n          });\n        }\n      });\n    });\n\n    // Observe the entire document for button removal\n    buttonObserver.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n  }\n\n  function handleContentChange() {\n    cleanupOrphanedButtons();\n\n    // Don't trigger injection immediately - let the MutationObserver handle it\n    // when the new textarea appears in the DOM\n  }\n\n  function handleTextareaChanges() {\n    debouncedInjectAIButtons();\n  }\n\n  function debouncedInjectAIButtons() {\n    const now = Date.now();\n    const timeSinceLastInjection = now - lastInjectionTime;\n\n    // Clear any existing timer first\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n      debounceTimer = null;\n    }\n\n    if (timeSinceLastInjection < INJECTION_DEBOUNCE_MS) {\n      const remainingTime = INJECTION_DEBOUNCE_MS - timeSinceLastInjection;\n\n      debounceTimer = window.setTimeout(() => {\n        performInjection();\n        debounceTimer = null;\n      }, remainingTime);\n\n    } else {\n      performInjection();\n    }\n  }\n\n  function performInjection() {\n    // Prevent concurrent injections\n    if (isInjecting) {\n      return;\n    }\n\n    isInjecting = true;\n    lastInjectionTime = Date.now();\n\n    try {\n      // Clean up orphaned buttons first\n      cleanupOrphanedButtons();\n\n      // Find all textareas that need enhancement\n      const textareas = findAllReplyTextareas();\n\n      if (textareas.length > 0) {\n        let successfulInjections = 0;\n        let skippedInjections = 0;\n\n        textareas.forEach((textarea, index) => {\n          const existingButton = findExistingButtonForTextarea(textarea);\n          if (existingButton) {\n            skippedInjections++;\n          } else {\n            const success = injectAIButtonForTextarea(textarea, index);\n            if (success) {\n              successfulInjections++;\n            }\n          }\n        });\n      }\n    } finally {\n      // Always reset the flag\n      isInjecting = false;\n    }\n  }\n\n  function findAllReplyTextareas(): HTMLTextAreaElement[] {\n    // Use only the specific Google selector provided by the user\n    const specificSelector = '[jsname=\"YPqjbf\"]';\n    const foundTextareas: HTMLTextAreaElement[] = [];\n\n    try {\n      const element = document.querySelector(specificSelector) as HTMLTextAreaElement;\n\n      if (element && (element.tagName === 'TEXTAREA' || element.hasAttribute('contenteditable'))) {\n        // Verify this is actually a reply textarea and not already processed\n        if (isLikelyReplyTextarea(element) && !hasAssociatedButton(element)) {\n          foundTextareas.push(element);\n        }\n      }\n    } catch (error) {\n      // Ignore errors with selector\n    }\n\n    return foundTextareas;\n  }\n\n  function isLikelyReplyTextarea(element: HTMLElement): boolean {\n    // Since we're using the specific jsname=\"YPqjbf\" selector, we can be more lenient\n    // but still verify it's actually a reply-related textarea\n\n    // Check if it's a textarea or contenteditable\n    if (element.tagName !== 'TEXTAREA' && !element.hasAttribute('contenteditable')) {\n      return false;\n    }\n\n    // Check if it has the specific jsname attribute we expect\n    if (element.getAttribute('jsname') !== 'YPqjbf') {\n      return false;\n    }\n\n    // Additional validation for reply-related context\n    const placeholder = (element as HTMLTextAreaElement | HTMLInputElement).placeholder || element.getAttribute('data-placeholder') || '';\n    const keywords = ['reply', 'respond', 'comment', 'response'];\n\n    const hasReplyKeyword = keywords.some(keyword =>\n      placeholder.toLowerCase().includes(keyword)\n    );\n\n    // Check if element is in a form context (Google Business reviews are typically in forms)\n    const isInForm = element.closest('form') !== null;\n\n    // Since we found it with the specific selector, it's likely valid, but let's be thorough\n    return hasReplyKeyword || isInForm || element.getAttribute('jsname') === 'YPqjbf';\n  }\n\n  function hasAssociatedButton(textarea: HTMLElement): boolean {\n    // Check if there's already a button for this specific textarea (by jsname)\n    const jsname = textarea.getAttribute('jsname');\n    const textareaId = textarea.id;\n\n    if (jsname) {\n      // Check all buttons associated with this jsname\n      const allButtons = document.querySelectorAll('.ai-review-button');\n      for (const button of allButtons) {\n        const buttonJsname = button.getAttribute('data-associated-jsname');\n        if (buttonJsname === jsname) {\n          return true;\n        }\n      }\n    }\n\n    // Also check if there's a button in the same container\n    const container = textarea.closest('form, .modal, .dialog, .review-reply-container') || textarea.parentElement;\n    if (container) {\n      const nearbyButton = container.querySelector('.ai-review-button');\n      if (nearbyButton) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function cleanupOrphanedButtons() {\n    const existingButtons = document.querySelectorAll('.ai-review-button');\n    let cleanedCount = 0;\n\n    existingButtons.forEach(button => {\n      const associatedJsname = button.getAttribute('data-associated-jsname');\n      const injectionTimestamp = button.getAttribute('data-injection-timestamp');\n\n      // Check if the associated textarea still exists\n      let textareaExists = false;\n      if (associatedJsname) {\n        const textarea = document.querySelector(`[jsname=\"${associatedJsname}\"]`);\n        textareaExists = textarea !== null && document.contains(textarea);\n      }\n\n      // If textarea doesn't exist, always remove the button\n      if (!textareaExists) {\n        if (button.parentNode) {\n          button.remove();\n        }\n        injectedButtons.delete(button as HTMLElement);\n        cleanedCount++;\n      }\n      // Only remove old buttons if they're really old (>10 minutes) to avoid removing active buttons\n      else if (injectionTimestamp) {\n        const buttonAge = Date.now() - parseInt(injectionTimestamp);\n        const isVeryOldButton = buttonAge > 10 * 60 * 1000; // 10 minutes\n\n        if (isVeryOldButton) {\n          button.remove();\n          injectedButtons.delete(button as HTMLElement);\n          cleanedCount++;\n        }\n      }\n    });\n  }\n\n  function findAssociatedTextarea(button: Element): HTMLElement | null {\n    // First, try to find the specific textarea with jsname=\"YPqjbf\" (Google's reply textarea)\n    const googleReplyTextarea = document.querySelector('textarea[jsname=\"YPqjbf\"]') ||\n                               document.querySelector('[jsname=\"YPqjbf\"]');\n    if (googleReplyTextarea) {\n      return googleReplyTextarea as HTMLElement;\n    }\n\n    // Fallback: Try to find textarea in the same container or nearby\n    const container = button.parentElement;\n    if (container) {\n      const textarea = container.querySelector('textarea') ||\n                      container.querySelector('[contenteditable=\"true\"]');\n      if (textarea) {\n        return textarea as HTMLElement;\n      }\n    }\n\n    // Look for textarea before the button's container\n    const previousTextarea = button.parentElement?.previousElementSibling?.querySelector('textarea') ||\n                           button.parentElement?.previousElementSibling?.querySelector('[contenteditable=\"true\"]');\n    if (previousTextarea) {\n      return previousTextarea as HTMLElement;\n    }\n\n    // Last resort: look for any textarea on the page\n    const anyTextarea = document.querySelector('textarea');\n    if (anyTextarea) {\n      return anyTextarea as HTMLElement;\n    }\n\n    return null;\n  }\n\n  function injectAIButtonForTextarea(textarea: HTMLElement, index: number): boolean {\n    // Check if we already have a button for this textarea\n    const existingButton = findExistingButtonForTextarea(textarea);\n\n    if (existingButton) {\n      return false;\n    }\n\n    try {\n      const button = createAIButton(textarea);\n      const injectionPoint = findBestInjectionPoint(textarea);\n\n      if (injectionPoint) {\n        injectButtonAtPoint(button, injectionPoint, textarea);\n        injectedButtons.add(button);\n        return true;\n      } else {\n        return false;\n      }\n    } catch (error) {\n      console.error(`‚ùå Failed to inject button for textarea ${index + 1}:`, error);\n      return false;\n    }\n  }\n\n  function findExistingButtonForTextarea(textarea: HTMLElement): HTMLElement | null {\n    // Comprehensive search for existing buttons associated with this textarea\n\n    // Method 1: Check by associated textarea ID in button attributes\n    const textareaId = textarea.id || textarea.getAttribute('jsname') || 'anonymous-textarea';\n    const allButtons = document.querySelectorAll('.ai-review-button');\n\n    for (const button of allButtons) {\n      const buttonTextareaId = button.getAttribute('data-associated-textarea');\n      if (buttonTextareaId === textareaId && injectedButtons.has(button as HTMLElement)) {\n        return button as HTMLElement;\n      }\n    }\n\n    // Method 2: Check in the same container hierarchy\n    const containerSelectors = [\n      '.review-reply-container',\n      '.reply-form',\n      'form',\n      '.modal',\n      '.dialog',\n      '.review-item',\n      '.comment-form'\n    ];\n\n    for (const selector of containerSelectors) {\n      const container = textarea.closest(selector);\n      if (container) {\n        const button = container.querySelector('.ai-review-button') as HTMLElement;\n        if (button && injectedButtons.has(button)) {\n          return button;\n        }\n      }\n    }\n\n    // Method 3: Check parent elements (up to 3 levels)\n    let currentElement: HTMLElement | null = textarea;\n    for (let i = 0; i < 3 && currentElement; i++) {\n      const button = currentElement.querySelector('.ai-review-button') as HTMLElement;\n      if (button && injectedButtons.has(button)) {\n        return button;\n      }\n      currentElement = currentElement.parentElement;\n    }\n\n    return null;\n  }\n\n  function createAIButton(textarea: HTMLElement): HTMLElement {\n    const button = document.createElement('button');\n    button.textContent = 'Bolt Reply';\n    button.className = 'ai-review-button VfPpkd-LgbsSe VfPpkd-LgbsSe-OWXEXe-k8QpJ VfPpkd-LgbsSe-OWXEXe-dgl2Hf nCP5yc AjY5Oe DuMIQc LQeN7 FwaX8';\n    button.setAttribute('data-textarea-id', textarea.id || 'textarea-' + Date.now());\n\n    button.style.cssText = `\n      margin: 0 8px 0 0;\n      padding: 8px 16px;\n      background: hsl(217, 91%, 60%);\n      color: white;\n      border: none;\n      border-radius: 6px;\n      cursor: pointer;\n      font-size: 14px;\n      font-family: 'Inter', 'Google Sans', Roboto, Arial, sans-serif;\n      font-weight: 500;\n      transition: background-color 0.2s;\n      box-shadow: 0 1px 3px rgba(0,0,0,0.1);\n      backdrop-filter: blur(12px);\n      display: flex;\n      align-items: center;\n      gap: 6px;\n    `;\n\n    // Add hover effects\n    button.onmouseover = () => button.style.backgroundColor = 'hsl(217, 91%, 50%)';\n    button.onmouseout = () => button.style.backgroundColor = 'hsl(217, 91%, 60%)';\n\n    // Add click handler\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      generateAIReply(textarea);\n    });\n\n    // Lightning bolt SVG icon (flat, white)\n    const lightningIcon = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"white\" style=\"flex-shrink: 0;\"><path d=\"M13 2L3 14h9l-1 8 10-12h-9l1-8z\"/></svg>`;\n\n    // Add Google-like inner structure with lightning icon\n    button.innerHTML = `\n      <div class=\"VfPpkd-Jh9lGc\"></div>\n      <div class=\"VfPpkd-J1Ukfc-LhBDec\"></div>\n      <div class=\"VfPpkd-RLmnJb\"></div>\n      <span jsname=\"V67aGc\" class=\"VfPpkd-vQzf8d\" style=\"display: flex; align-items: center; gap: 6px;\">${lightningIcon} Bolt Reply</span>\n    `;\n\n    return button;\n  }\n\n  function findBestInjectionPoint(textarea: HTMLElement): { container: HTMLElement; reference: HTMLElement | null } | null {\n    // Strategy 1: Look for Google-specific button container\n    const googleContainer = document.querySelector('div.FkJOzc.lgfhc.LW6Hp') as HTMLElement;\n    if (googleContainer) {\n      const skipButton = googleContainer.querySelector('button[jsname=\"dmDvRc\"]') as HTMLElement;\n      if (skipButton) {\n        return { container: googleContainer, reference: skipButton };\n      }\n      // Use any button in the container\n      const anyButton = googleContainer.querySelector('button') as HTMLElement;\n      if (anyButton) {\n        return { container: googleContainer, reference: anyButton };\n      }\n    }\n\n    // Strategy 2: Find form buttons container\n    const form = textarea.closest('form');\n    if (form) {\n      const buttonContainer = form.querySelector('.button-container, .form-actions, .actions') as HTMLElement;\n      if (buttonContainer) {\n        return { container: buttonContainer, reference: buttonContainer.firstElementChild as HTMLElement };\n      }\n    }\n\n    // Strategy 3: Insert next to textarea\n    if (textarea.parentElement) {\n      return { container: textarea.parentElement, reference: textarea.nextElementSibling as HTMLElement };\n    }\n\n    return null;\n  }\n\n  function injectButtonAtPoint(button: HTMLElement, injectionPoint: { container: HTMLElement; reference: HTMLElement | null }, textarea: HTMLElement) {\n    if (injectionPoint.reference) {\n      // Insert before reference element\n      injectionPoint.container.insertBefore(button, injectionPoint.reference);\n    } else {\n      // Append to container\n      injectionPoint.container.appendChild(button);\n    }\n\n    // Mark button as injected for this textarea using jsname for better identification\n    const textareaIdentifier = textarea.getAttribute('jsname') || textarea.id || 'anonymous-textarea';\n    button.setAttribute('data-associated-textarea', textareaIdentifier);\n    button.setAttribute('data-associated-jsname', textarea.getAttribute('jsname') || '');\n    button.setAttribute('data-injection-timestamp', Date.now().toString());\n  }\n\n  // ==================== LEGACY FUNCTIONS (KEPT FOR COMPATIBILITY) ====================\n\n  function initializeReplyFormEnhancement() {\n    initializeDynamicInjectionSystem();\n  }\n\n  function enhanceReplyForm(replyTextarea: HTMLElement) {\n    // This function is now handled by the dynamic injection system\n    // Just trigger a scan for this specific textarea\n    debouncedInjectAIButtons();\n  }\n\n  function insertAIButton(container: HTMLElement, referenceButton: HTMLElement, replyTextarea: HTMLElement) {\n    // This is now handled by injectButtonAtPoint\n    const injectionPoint = { container, reference: referenceButton };\n    const button = createAIButton(replyTextarea);\n    injectButtonAtPoint(button, injectionPoint, replyTextarea);\n    injectedButtons.add(button);\n  }\n\n  function fallbackButtonInjection(replyTextarea: HTMLElement) {\n    // This is now handled by findBestInjectionPoint strategy 3\n    debouncedInjectAIButtons();\n  }\n\n  function generateAIReply(replyElement: HTMLElement) {\n    try {\n      // Extract review data using the provided selectors\n      const reviewData = extractReviewData();\n      if (!reviewData) {\n        console.error('‚ùå Could not extract review data');\n        showErrorMessage('Could not extract review data. Please try again.');\n        return;\n      }\n\n      // Show loading state\n      showLoadingState(replyElement);\n\n      // Send message to background script to generate AI response\n      chrome.runtime.sendMessage({\n        type: 'GENERATE_AI_RESPONSE',\n        data: {\n          reviewData: reviewData\n        }\n      }, (response) => {\n        if (response && response.success) {\n          // Success - insert the generated response\n          const aiResponse = response.aiResponse || '';\n\n          // Only insert if we have a valid response or if textarea is empty\n          // This prevents overwriting a valid response with an empty one\n          const currentValue = replyElement.tagName === 'TEXTAREA' || replyElement.tagName === 'INPUT'\n            ? (replyElement as HTMLInputElement | HTMLTextAreaElement).value\n            : replyElement.textContent || '';\n\n          if (aiResponse.length > 0 || currentValue.length === 0) {\n            insertGeneratedResponse(replyElement, aiResponse);\n          }\n\n          // Notify parent frame\n          if (window.parent && window.parent !== window) {\n            window.parent.postMessage({\n              type: 'REPLY_GENERATED',\n              data: {\n                replyLength: aiResponse.length,\n                reviewTextLength: reviewData.review_text ? reviewData.review_text.length : 0,\n                confidence: response.confidence,\n                processingTime: response.processingTime,\n                tokensUsed: response.tokensUsed,\n                timestamp: new Date().toISOString()\n              }\n            }, '*');\n          }\n        } else {\n          // Error handling\n          console.error('‚ùå Error generating AI response:', response?.error);\n          showErrorMessage(response?.error || 'Failed to generate AI response');\n          hideLoadingState(replyElement);\n        }\n      });\n\n    } catch (error) {\n      console.error('‚ùå Error in generateAIReply:', error);\n      showErrorMessage('An unexpected error occurred. Please try again.');\n      hideLoadingState(replyElement);\n    }\n  }\n\n  function showLoadingState(replyElement: HTMLElement) {\n    // Disable the button and show loading state\n    const button = document.querySelector('.ai-review-button') as HTMLElement;\n    if (button) {\n      const lightningIcon = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"white\" style=\"flex-shrink: 0;\"><path d=\"M13 2L3 14h9l-1 8 10-12h-9l1-8z\"/></svg>`;\n      button.innerHTML = `<span style=\"display: flex; align-items: center; gap: 6px;\">${lightningIcon} Generating...</span>`;\n      button.style.opacity = '0.6';\n      button.style.pointerEvents = 'none';\n    }\n\n    // Optionally show a loading indicator in the textarea\n    if (replyElement.hasAttribute('placeholder')) {\n      const originalPlaceholder = replyElement.getAttribute('placeholder') || '';\n      replyElement.setAttribute('data-original-placeholder', originalPlaceholder);\n      replyElement.setAttribute('placeholder', 'Generating AI response...');\n    }\n  }\n\n  function hideLoadingState(replyElement: HTMLElement) {\n    // Re-enable the button\n    const button = document.querySelector('.ai-review-button') as HTMLElement;\n    if (button) {\n      const lightningIcon = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"white\" style=\"flex-shrink: 0;\"><path d=\"M13 2L3 14h9l-1 8 10-12h-9l1-8z\"/></svg>`;\n      button.innerHTML = `<span style=\"display: flex; align-items: center; gap: 6px;\">${lightningIcon} Bolt Reply</span>`;\n      button.style.opacity = '1';\n      button.style.pointerEvents = 'auto';\n    }\n\n    // Restore original placeholder\n    if (replyElement.hasAttribute('data-original-placeholder')) {\n      const originalPlaceholder = replyElement.getAttribute('data-original-placeholder') || '';\n      replyElement.setAttribute('placeholder', originalPlaceholder);\n      replyElement.removeAttribute('data-original-placeholder');\n    }\n  }\n\n  function insertGeneratedResponse(replyElement: HTMLElement, response: string) {\n    hideLoadingState(replyElement);\n\n    // Fill the reply form\n    if (replyElement.tagName === 'TEXTAREA' || replyElement.tagName === 'INPUT') {\n      (replyElement as HTMLInputElement | HTMLTextAreaElement).value = response;\n      // Trigger input event to notify any listeners\n      replyElement.dispatchEvent(new Event('input', { bubbles: true }));\n    } else if (replyElement.hasAttribute('contenteditable')) {\n      replyElement.textContent = response;\n      // Trigger input event for contenteditable\n      replyElement.dispatchEvent(new Event('input', { bubbles: true }));\n    }\n\n    // Optionally, focus the element to show the response\n    replyElement.focus();\n  }\n\n  function showErrorMessage(message: string) {\n    // Create a temporary error message\n    const errorDiv = document.createElement('div');\n    errorDiv.textContent = `‚ùå ${message}`;\n    errorDiv.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: hsl(0, 84%, 60%);\n      color: white;\n      padding: 12px 16px;\n      border-radius: 6px;\n      font-size: 14px;\n      font-family: 'Inter', sans-serif;\n      z-index: 10000;\n      box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n      max-width: 300px;\n      backdrop-filter: blur(12px);\n    `;\n\n    document.body.appendChild(errorDiv);\n\n    // Remove after 5 seconds\n    setTimeout(() => {\n      if (errorDiv.parentNode) {\n        errorDiv.remove();\n      }\n    }, 5000);\n  }\n\n  function handleAIResponseResult(data: any) {\n    try {\n      // Find the associated textarea/button\n      const button = document.querySelector('.ai-review-button') as HTMLElement;\n\n      const textarea = button ? findAssociatedTextarea(button) : null;\n\n      if (data && data.success && data.aiResponse && typeof data.aiResponse === 'string') {\n        // Success - insert the response\n        if (textarea) {\n          // Check current textarea content to avoid unnecessary overwrites\n          const currentValue = textarea.tagName === 'TEXTAREA' || textarea.tagName === 'INPUT'\n            ? (textarea as HTMLInputElement | HTMLTextAreaElement).value\n            : textarea.textContent || '';\n\n          // Only insert if the response has content or textarea is empty\n          if (data.aiResponse.length > 0 || currentValue.length === 0) {\n            insertGeneratedResponse(textarea, data.aiResponse);\n          }\n        }\n\n        // Show success message\n        showSuccessMessage('AI response generated successfully!');\n      } else {\n        // Error handling\n        console.error('‚ùå AI response failed:', data?.error || 'Unknown error');\n        if (textarea) {\n          hideLoadingState(textarea);\n        }\n        showErrorMessage(data?.error || 'Failed to generate AI response');\n      }\n    } catch (error) {\n      console.error('‚ùå Error handling AI response result:', error);\n      // Try to hide loading state even if there's an error\n      try {\n        const button = document.querySelector('.ai-review-button') as HTMLElement;\n        const textarea = button ? findAssociatedTextarea(button) : null;\n        if (textarea) {\n          hideLoadingState(textarea);\n        }\n      } catch (hideError) {\n        console.error('‚ùå Error hiding loading state:', hideError);\n      }\n      showErrorMessage('An unexpected error occurred while processing the response');\n    }\n  }\n\n  function handleProgressUpdate(data: any) {\n    try {\n      // Update button text to show progress\n      const button = document.querySelector('.ai-review-button') as HTMLElement;\n      if (button && data) {\n        const statusText = getStatusText(data.status);\n        const progressText = (typeof data.progress === 'number') ? ` (${data.progress}%)` : '';\n        button.textContent = `ü§ñ ${statusText}${progressText}`;\n      }\n    } catch (error) {\n      console.error('‚ùå Error updating progress:', error);\n    }\n  }\n\n  function getStatusText(status: string): string {\n    switch (status) {\n      case 'pending':\n        return 'Queued...';\n      case 'processing':\n        return 'Generating...';\n      case 'completed':\n        return 'Complete!';\n      case 'failed':\n        return 'Failed';\n      default:\n        return 'Processing...';\n    }\n  }\n\n  function showSuccessMessage(message: string) {\n    // Create a temporary success message\n    const successDiv = document.createElement('div');\n    successDiv.textContent = `‚úÖ ${message}`;\n    successDiv.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: hsl(142, 76%, 36%);\n      color: white;\n      padding: 12px 16px;\n      border-radius: 6px;\n      font-size: 14px;\n      font-family: 'Inter', sans-serif;\n      z-index: 10000;\n      box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n      max-width: 300px;\n      backdrop-filter: blur(12px);\n    `;\n\n    document.body.appendChild(successDiv);\n\n    // Remove after 3 seconds\n    setTimeout(() => {\n      if (successDiv.parentNode) {\n        successDiv.remove();\n      }\n    }, 3000);\n  }\n\n  function findReviewText(): string {\n    // Try to extract review data using the provided selectors first\n    const reviewData = extractReviewData();\n    if (reviewData && reviewData.review_text) {\n      return reviewData.review_text;\n    }\n\n    // Fallback to legacy selectors if the new ones don't work\n\n    // Comprehensive selectors for finding review content\n    const reviewSelectors = [\n      // Google-specific selectors\n      '[data-review-text]',\n      '[data-message-text]',\n      '.review-text',\n      '.review-content',\n      '.review-body',\n      '[class*=\"review\"]',\n      // Generic content selectors\n      '[class*=\"content\"]',\n      '[class*=\"message\"]',\n      '[class*=\"comment\"]',\n      // Fallback to any text content in the main content area\n      'main [class*=\"text\"]',\n      'article [class*=\"text\"]',\n      '.main-content',\n      '#main-content'\n    ];\n\n    for (const selector of reviewSelectors) {\n      try {\n        const elements = document.querySelectorAll(selector);\n        for (const element of elements) {\n          if (element && element.textContent && element.textContent.trim().length > 20) {\n            const text = element.textContent.trim();\n            // Make sure it's not our button text or other UI text\n            if (!text.includes('Bolt Reply') && !text.includes('Omitir') && !text.includes('Reply')) {\n              return text;\n            }\n          }\n        }\n      } catch (error) {\n        // Ignore selector errors\n      }\n    }\n\n    // Last resort: look for any substantial text content\n    const allTextElements = document.querySelectorAll('p, div, span');\n    for (const element of allTextElements) {\n      if (element.textContent && element.textContent.trim().length > 50) {\n        const text = element.textContent.trim();\n        if (!text.includes('Bolt Reply') && !text.includes('Omitir')) {\n          return text;\n        }\n      }\n    }\n\n    return 'Thank you for your valuable feedback. We appreciate you taking the time to share your experience with us.';\n  }\n\n  function extractReviewData() {\n    try {\n      // Extract reviewer name using the provided selector\n      const reviewerNameElement = document.querySelector('#AH1dze > div > div > main > div > div > c-wiz > div > div > article > div.noyJyc > div > div > div.N0c6q.JhRJje') as HTMLElement;\n      const reviewer_name = reviewerNameElement?.textContent?.trim() || undefined;\n\n      // Extract rating from the star rating span - multiple fallback methods\n      let review_rating: number | undefined;\n\n      // Method 1: Try the specific Google Business rating span with DYizzd class\n      const ratingElement = document.querySelector('span.DYizzd[aria-label]') as HTMLElement;\n      if (ratingElement) {\n        const ariaLabel = ratingElement.getAttribute('aria-label') || '';\n\n        // Handle both Spanish and English formats, including non-breaking spaces\n        const match = ariaLabel.match(/(\\d+)\\s*(?:de|out of)\\s*5\\s*(?:estrellas?|stars?)/i);\n        if (match) {\n          review_rating = parseInt(match[1], 10);\n        }\n      }\n\n      // Method 2: Fallback - count filled stars by checking for the filled star class\n      if (!review_rating && ratingElement) {\n        const filledStars = ratingElement.querySelectorAll('i.VfPpkd-kBDsod.lMAmUc:not(.VOmEhb)');\n        if (filledStars.length > 0) {\n          review_rating = filledStars.length;\n        }\n      }\n\n      // Method 3: Alternative selector for older Google layouts\n      if (!review_rating) {\n        const altRatingElement = document.querySelector('span[aria-label*=\"de 5 estrellas\"], span[aria-label*=\"out of 5 stars\"]') as HTMLElement;\n        if (altRatingElement) {\n          const ariaLabel = altRatingElement.getAttribute('aria-label') || '';\n          const match = ariaLabel.match(/(\\d+)\\s*(?:de|out of)\\s*5/);\n          if (match) {\n            review_rating = parseInt(match[1], 10);\n          }\n        }\n      }\n\n      // Method 4: Look for any span with rating-like aria-label\n      if (!review_rating) {\n        const allRatingSpans = document.querySelectorAll('span[aria-label]');\n        for (const span of allRatingSpans) {\n          const ariaLabel = span.getAttribute('aria-label') || '';\n          const match = ariaLabel.match(/(\\d+)\\s*(?:de|out of|\\/)\\s*5\\s*(?:estrellas?|stars?)?/i);\n          if (match) {\n            review_rating = parseInt(match[1], 10);\n            break;\n          }\n        }\n      }\n\n      // Method 5: Last resort - look for star icons and count them\n      if (!review_rating) {\n        const starIcons = document.querySelectorAll('i[aria-hidden=\"true\"]:not(.VOmEhb)');\n        if (starIcons.length > 0 && starIcons.length <= 5) {\n          review_rating = starIcons.length;\n        }\n      }\n\n      // Extract review text using the provided selector\n      const reviewTextElement = document.querySelector('div.gyKkFe.JhRJje.Fv38Af') as HTMLElement;\n      const extracted_text = reviewTextElement?.textContent?.trim();\n\n      // Handle empty reviews gracefully\n      let review_text: string;\n      if (!extracted_text || extracted_text.length === 0) {\n        // Empty review - provide a meaningful placeholder\n        review_text = \"[Review with no text content]\";\n      } else {\n        review_text = extracted_text;\n      }\n\n      // Method 6: Default fallback - assume rating based on sentiment if still undefined\n      if (!review_rating) {\n        // If we have review text, try to infer sentiment\n        const hasPositiveWords = review_text && review_text !== \"[Review with no text content]\" && (\n          review_text.toLowerCase().includes('great') ||\n          review_text.toLowerCase().includes('excellent') ||\n          review_text.toLowerCase().includes('amazing') ||\n          review_text.toLowerCase().includes('love') ||\n          review_text.toLowerCase().includes('fantastic')\n        );\n\n        const hasNegativeWords = review_text && review_text !== \"[Review with no text content]\" && (\n          review_text.toLowerCase().includes('bad') ||\n          review_text.toLowerCase().includes('terrible') ||\n          review_text.toLowerCase().includes('worst') ||\n          review_text.toLowerCase().includes('disappointed') ||\n          review_text.toLowerCase().includes('awful')\n        );\n\n        if (hasPositiveWords && !hasNegativeWords) {\n          review_rating = 5;\n        } else if (hasNegativeWords) {\n          review_rating = 1;\n        } else {\n          review_rating = 3;\n        }\n      }\n\n      // Validate that we have basic review data (at minimum, we should have a rating or reviewer)\n      if (!reviewer_name && !review_rating && review_text === \"[Review with no text content]\") {\n        return null;\n      }\n\n      const reviewData = {\n        reviewer_name,\n        review_rating,\n        review_text,\n        website_url: window.location.href,\n        source_platform: 'Google'\n      };\n\n      return reviewData;\n\n    } catch (error) {\n      console.error('‚ùå Error extracting review data:', error);\n      return null;\n    }\n  }\n\n  function generateReplyContent(reviewText: string): string {\n    // This is where you would integrate with your AI service\n    // For now, we'll generate a contextual response based on the review content\n\n    const lowerReview = reviewText.toLowerCase();\n\n    // Analyze sentiment and content\n    const isPositive = lowerReview.includes('great') || lowerReview.includes('excellent') || lowerReview.includes('amazing') || lowerReview.includes('love');\n    const isNegative = lowerReview.includes('bad') || lowerReview.includes('terrible') || lowerReview.includes('worst') || lowerReview.includes('disappointed');\n    const isSuggestion = lowerReview.includes('suggest') || lowerReview.includes('could') || lowerReview.includes('would be better');\n\n    if (isPositive) {\n      return `Thank you so much for your wonderful feedback! We're thrilled to hear that you're enjoying our service. Your positive experience means everything to us, and we look forward to serving you again soon!`;\n    } else if (isNegative) {\n      return `We're truly sorry to hear about your disappointing experience. Your feedback is incredibly valuable to us, and we're committed to improving our service. We'll review this carefully and work to ensure better experiences for all our customers.`;\n    } else if (isSuggestion) {\n      return `Thank you for your thoughtful suggestion! We truly appreciate you taking the time to share your ideas for improvement. Your feedback helps us enhance our service for everyone. We'll definitely consider implementing this.`;\n    } else {\n      return `Thank you for your feedback! We genuinely appreciate you taking the time to share your experience with us. Your input helps us continue to improve and provide the best possible service to all our customers.`;\n    }\n  }\n\n  // ==================== CLEANUP AND MEMORY MANAGEMENT ====================\n\n  function cleanup() {\n    // Clear intervals\n    if (urlCheckInterval) {\n      clearInterval(urlCheckInterval);\n      urlCheckInterval = null;\n    }\n\n    // Clear debounce timer\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n      debounceTimer = null;\n    }\n\n    // Disconnect mutation observer\n    if (mutationObserver) {\n      mutationObserver.disconnect();\n      mutationObserver = null;\n    }\n\n    // Disconnect button observer\n    if (buttonObserver) {\n      buttonObserver.disconnect();\n      buttonObserver = null;\n    }\n\n    // Clear injected buttons set\n    injectedButtons.clear();\n  }\n\n  // Cleanup on page unload\n  window.addEventListener('beforeunload', cleanup);\n\n  // Cleanup on iframe navigation (in case iframe is reused)\n  window.addEventListener('pagehide', cleanup);\n\n  // Periodic health check\n  setInterval(() => {\n    // Keep minimal health check if needed, or remove. I'll leave it empty effectively or just remove the log.\n  }, 30000); // Every 30 seconds\n\n  // ==================== LEGACY MONITORING (KEPT FOR BACKWARD COMPATIBILITY) ====================\n\n  function monitorForReplyNavigation() {\n    // This is now handled by the dynamic injection system\n    initializeDynamicInjectionSystem();\n  }\n\n})();\n"],"names":["lastKnownUrl","window","location","href","mutationObserver","urlCheckInterval","injectedButtons","Set","buttonObserver","debounceTimer","lastInjectionTime","isInjecting","parent","postMessage","type","data","url","timestamp","Date","toISOString","chrome","runtime","onMessage","addListener","message","sender","sendResponse","button","document","querySelector","textarea","findAssociatedTextarea","success","aiResponse","currentValue","tagName","value","textContent","length","insertGeneratedResponse","successDiv","createElement","style","cssText","body","appendChild","setTimeout","parentNode","remove","showSuccessMessage","console","error","hideLoadingState","showErrorMessage","hideError","handleAIResponseResult","statusText","status","getStatusText","progressText","progress","handleProgressUpdate","currentUrl","hasCustomersReviews","includes","debouncedInjectAIButtons","timeSinceLastInjection","now","clearTimeout","remainingTime","performInjection","cleanupOrphanedButtons","textareas","foundTextareas","element","hasAttribute","getAttribute","placeholder","hasReplyKeyword","some","keyword","toLowerCase","isInForm","closest","isLikelyReplyTextarea","jsname","id","allButtons","querySelectorAll","container","parentElement","hasAssociatedButton","push","findAllReplyTextareas","successfulInjections","skippedInjections","forEach","index","findExistingButtonForTextarea","className","setAttribute","onmouseover","backgroundColor","onmouseout","addEventListener","e","preventDefault","stopPropagation","replyElement","reviewData","reviewerNameElement","reviewer_name","trim","undefined","review_rating","ratingElement","match","parseInt","filledStars","altRatingElement","allRatingSpans","span","starIcons","reviewTextElement","extracted_text","review_text","hasPositiveWords","hasNegativeWords","website_url","source_platform","extractReviewData","lightningIcon","innerHTML","opacity","pointerEvents","originalPlaceholder","showLoadingState","sendMessage","response","replyLength","reviewTextLength","confidence","processingTime","tokensUsed","generateAIReply","createAIButton","injectionPoint","googleContainer","skipButton","reference","anyButton","form","buttonContainer","firstElementChild","nextElementSibling","findBestInjectionPoint","insertBefore","textareaIdentifier","toString","injectButtonAtPoint","add","injectAIButtonForTextarea","associatedJsname","injectionTimestamp","textareaExists","contains","delete","googleReplyTextarea","previousTextarea","previousElementSibling","textareaId","has","containerSelectors","selector","currentElement","i","removeAttribute","dispatchEvent","Event","bubbles","focus","errorDiv","cleanup","clearInterval","disconnect","clear","setInterval","MutationObserver","mutations","shouldTriggerScan","relevantChanges","mutation","addedNodes","node","nodeType","Node","ELEMENT_NODE","matches","removedNodes","Array","from","target","attributeName","observe","childList","subtree","attributes","attributeFilter","classList"],"sourceRoot":""}